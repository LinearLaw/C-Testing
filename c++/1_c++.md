# C++

```c++
// hello world
#include<iostream>      // 头文件引入
using namespace std;    // 规定使用标准命名空间

int main(){	
    // cout是C++标准输出流，endl是输出换行并刷新缓冲区
    // 两个放到一起，这句和printf效果一样
	cout << "hello world" << endl;
	return EXIT_SUCCESS;
}

```
面向过程思想核心：功能分解、自顶向下、逐层细化；  
> 程序 = 数据结构 + 算法    

面向对象思想核心：应对变化、提高复用；
> 对象 = 算法 + 数据结构    
> 程序 = 对象 + 对象 + 对象 + ...       

--------------------------------------------

面向对象三大特性    
- 封装：客观事物封装成抽象的类      
- 继承：类之间的相互关系
- 多态：一种接口，多种方法

## C++对C的扩展

- ::作用域运算符

————————————————————————————————————————————

- 命名空间namespace

————————————————————————————————————————————

- using声明：using之后就将目标命名空间内的变量都引入了

————————————————————————————————————————————

- 全局变量检测增强

————————————————————————————————————————————

- 更严格的类型检查

————————————————————————————————————————————

- 更严格的类型转换

————————————————————————————————————————————

- struct功能增强

————————————————————————————————————————————

- bool类型关键字

————————————————————————————————————————————

- 三目运算符功能增强
```c
/**
 * 可以放在赋值操作符左边的是左值，可以放到赋值操作符右边的是右值
 * 
 * 这里的a就是一个左值，10是一个右值
 * 左值就是可以重新给它赋值的东西，例如变量，是一个内存地址的引用
 * 右值就是一个值，不能给它重新赋值，它不是一个引用；
 * 
 * 有些变量可以做左值也可以做右值；
 */
int a = 10;
int b = a;
```
————————————————————————————————————————————

- const
```c
在c++中，一个const不必创建内存空间，
而在c中，一个const总是需要一块内存空间。

不过，取一个const地址, 或者把它定义为extern,则会为该const创建内存空间。

在C++中，出现在所有函数之外的const作用于整个文件，在该文件外不可见，
即默认为内部连接，C++中其他的标识符一般默认为外部连接。
```
**const在C和C++中的编译过程是不同的。**         
c中const默认为外部连接，c++中const默认为内部连接。      

宏常量是没有命名空间的。    
宏常量并不重视作用域，定义在当前文件任何位置都能访问到，或者是出现了#undef。      
宏常量没有类型，const有类型。       

————————————————————————————————————————————

- 引用（重点）  
```c
int a = 10;
int& b = a; // b作为a变量的别名，
```
注意：引用不可以有NULL，必须跟某一个存储单元关联；
引用必须要初始化，在定义的时候就必须要指向一个单元。      
并且一旦初始化就不可更改。  
可以对数组进行引用。    

```c
int& c; // 这种写法错误
int& d = a;
d = b; // 这个操作不允许

// 直接引用数组是不通过的
int arr[10];
int& ref[10] = arr;  // 本句报错；
```
如何对数组进行引用？    
```c
// 方法一：
typedef int ArrRef[10]; 
int arr[10];
ArrRef aRef = arr;
for(int i = 0;i<10;i++){
    aRef[i] = i+1;
};

// 方法二
int(&f)[10] = arr;
for (int i = 0; i < 10; i++){
	f[i] = i+10;
}
```
函数中的引用    
```c
// 函数传值
void ValueSwap(int m,int n){
	int temp = m;
	m = n;
	n = temp;
}
ValueSwap(a, b);

// 函数传指针
void PointerSwap(int* m,int* n){
	int temp = *m;
	*m = *n;
	*n = temp;
}
PointerSwap(&a, &b);

// 函数传引用
void ReferenceSwap(int& m,int& n){
	int temp = m;
	m = n;
	n = temp;
}
ReferenceSwap(a, b);

/*
显然，这三种方式，函数形参的写法不一样，调用时传值也不一样。
*/
```
```c
// 函数返回值为引用类型，不可以返回局部变量的引用
int& test()
{
    int a = 10;
    return a;   // 该行为不允许，不能局部变量的引用
}
// 函数当左值，必须返回引用
int& test1()
{
    int a = 20;
    return a;
}
test1() = 100;  // test1的返回值作为左值，此时需要返回引用才行；
```
引用的实质：引用的本质就是一个指针常量；
```c
// 以下两句等价
int* const a = &val;
int& a = val;
```

--------------------------------------------

指针引用
```c
struct Teacher
{
    int age;
}
// 使用指针修改结构体成员
void testPointer(Teacher** tc)
{
    *tc = (Teacher*)malloc(sizeof(Teacher));
    (*teacher)->age = 200;
}

// 使用引用修改结构体成员，传入一个结构体的指针引用
void test(Teacher*& tc)
{
    tc->age = 300;
}

```
--------------------------------------------
常量引用
```c
const int& ref = val;
```
注意：const修饰的引用不可修改；
```c
// 不能将一个字面量赋值给引用，下面这个操作不被允许
int& ref = 100;     // 报错

// 但是常量引用可以赋值，不会报错
const int& ref = 100;
```
> const引用的适用场景   
> - 函数的形参，比如复制、拷贝构造函数；    
> - 函数的形参定义为常量引用，不会产生新的变量，减少了传参的开销；  
> - 引用可能导致实参因为形参的改变而发生改变，常量引用可以避免这种情况；

————————————————————————————————————————————

- 内联函数
在C语言中，通常会把短而执行频繁的计算写成宏，也就是#define，在预处理的阶段，    
程序中的所有宏的引用都会被替换成宏的实际值，从而避免了函数调用的开销。  
但是有点问题，
> ①、宏隐藏了真正的变量值，会隐藏一些难以发现的错误；   
> ②、在C++中，预处理器不允许访问类的成员，也就是预处理器宏不能用作类的成员函数；    

为了解决这些问题，C++引入了内联函数；
```c
// 问题1
#define ADD(x,y) x+y
int ret1 = ADD(10,20) * 10; // 本来期望ret1是300的，结果发现却是210
// 原因，预处理阶段，这句变成了 int ret1 = 10+20*10，导致错误


int add(int x,int y)
{
    return x+y;
}
int ret2 = add(10,20) * 10; // ret2为300，正常的函数，不会有宏的那种问题
```
```c
// 问题2
#define COMPARE(x,y) ((x) < (y))?(x):(y);
int a = 1;
int b = 3;
int ret1 = COMPARE(++a , b);    // 本句结果为3，显然是错误的结果
// 原因，int ret1 = ((++a)<(b))?(++a):(b); 明显地，a被++了两次；


int compare(int x, int y)
{
    return x<y?x:y;
}
let ret2 = compare(++a,b);  //  本句结果2，正常的函数可以返回正确的结果
```
```
// 问题3，宏函数没有作用域的概念，无法作为一个类的成员函数；

```
内联函数，是一个真正的函数，具有普通函数的所有行为；
```c
// 在原本的函数类型前加上inline，即可定义一个内联函数；
// 但是注意，函数体和声明必须同时存在；
// 下面这句没有任何效果；
inline void func(int a);

// 正确的写法
inline void func(int a){return a;}
```
inline函数会在编译的时候像预定义宏一样展开，不占用调用函数的开销。      
注意：内联函数依然占用空间，但是相对于普通函数，内联函数省去了函数调用时的压栈、跳转、返回等开销，是一种以空间换时间的方式；    

注意：内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议；
要达成内联编译，需要具备以下条件：
> ①、不能存在任何形式的循环语句     
> ②、不能存在过多的条件判断语句     
> ③、函数体不能过于庞大     
> ④、不能对函数进行取址操作     

————————————————————————————————————————————

- 函数形参默认值
```c
void func(int a =10,int b = 20)
{

}

// 注意，函数默认参数从左到右，如果一个参数设置了默认参数，
//      那么这个参数之后的参数都必须设置默认参数
// 如果函数声明和定义分开，声明和定义中的默认值不能同时设置（要么声明里面写，要么定义里面写）
```
————————————————————————————————————————————
- 函数占位参数
```c
void func(int a, int b, int = 20)
{
    // 但是你无法在里面使用占位参数
}

// 那这玩意有啥用？答案是用于操作符重载
```
————————————————————————————————————————————

- 函数重载（overload）
> 实现函数重载，首先要满足同名函数在同一个作用域下，然后满足以下其中之一    
> - 参数个数不同    
> - 参数类型不同    
> - 参数顺序不同    

--------------------------------------------
```c++
namespace A{
    void func(){}
    void func(int a){}
    void func(string a){}
    void func(int a, string b){}
    void func(string a, int b){}
}
```
注意：两个同名函数，形参个数和类型一样，顺序一样，但是返回值不一样，    
函数的返回值不能作为重载的依据，因为C++编译器依然无法知道调用的时候到底调用的是哪个。   

--------------------------------------------

```c++
// 另外，如果使用了形参默认值，注意函数的二义性
namespace S{
    void func(string b){}
    void func(string b,int a = 10){}
}
func("hello");  // 此时，因为默认值的存在，C++编译器依然不知道调用的是哪个func
```
--------------------------------------------

重载是如何实现的？    
> 在C++编译的时候，同名的重载函数将会根据其形参特征重新命名，   
> 例如func(int x, char y)可能命名为_funcic      
> 例如func(int x)可能命名为_funci   
> 重命名的规则会依据编译平台的不同而不同。  

--------------------------------------------

extern "C"
> 因为重载编译重命名的影响，但是C编译不会出现重命名，这就会导致程序出错；   
> 因此需要为某一段代码单独设置以C语言方式进行编译和链接，因此就有了extern "C";      
>       
> **代码暂时不放了（有一丢丢长，之后再说，Todo list+1）**。    

--------------------------------------------

## 类和对象

struct结构体类型
> 在C语言中，struct中只有变量；     
> 在C++中，struct既有变量，也有函数；   

————————————————————————————————————————————

### 类
> C语言可以用结构体类型来描述某一个对象的各个属性，用函数来表示某个对象所具有的行为，   
> 但是这样有问题，某一个对象具有的行为不一定其他对象也具备，但是对于函数而言,它是不区分对象的，     
> 也就是说，我们需要将对象的属性和行为归到一起；    
> 另外，对象应该拥有不能被外界访问的私有属性和私有方法，只有对象自身才能访问；  

--------------------------------------------

- 封装
> 变量和属性合成整体，封装在一个类中，并对变量和函数进行访问控制；  

--------------------------------------------

- 访问权限控制
> 类的内部没有访问权限之分，所有成员可以互相访问；  
> 类的外部对类的内部，访问权限有三种：public, private, protected；  
> 类的外部，仅可访问类的public修饰的成员（此时先忽略继承与派生的情况）；     

> private和protected是同等级的，外部不允许访问。     
```c++
class Person
{   
    // 公有成员，外部可访问
    public:
        void say(){ cout << "这是一个Person类" << endl; }
    public:
        int high;

    // 以下为私有成员
    protected:
        int money;
    private:
        int age;
}

int main()
{
    Person p;
    p.money;    // 报错，私有成员不可访问
    p.say();    // 公共成员可以访问，打印出一句话

    return EXIT_SUCCESS;
}
```

> 注意，    
> class默认访问权限为private      
> struct默认的访问权限为public  
```c++
class ObjectA{ int age; }
struct ObjectB{ int age; }
int main()
{   
    // 创建两个对象
    ObjectA a;
    ObjectB b;
    a.age;  // 报错，class默认访问权限是private
    b.age;  // 可以访问
}
```
--------------------------------------------
将成员变量全部设置成private
> 将成员变量全部设置成private，然后用public的函数来对外提供访问内部成员的方法；     
> 这样的做法好处有很多，
> 1、当需要访问类成员时，全部通过函数来访问，无需考虑成员是public还是private；  
> 2、可以细分出内部变量的控制处理，例如进一步划分成只读不可写、不可读写，可读可写、只写不可读； 

--------------------------------------------
```c++
// 例、设计一个Person类

// 例、设计一个正方体类

// 例、设计一个线类和一个点类
```
### 对象构造和析构

对象创建出来之后，对象有一个初始状态，而当我们不需要这个对象时，需要将对象销毁。    

对象的初始化 → 构造函数     
对象的销毁 → 析构函数    

> 构造函数和析构函数会被编译器自动调用，完成对象的初始化和清理工作；    
> 所以编写类时，应该顺便提供初始化函数（不过不写初始化函数，编译器也会给你默认初始化）。    

--------------------------------------------

```c++
class Person{
public:
    /**
     * @desc 构造函数，创建对象时为对象的成员属性赋值，由编译器自动调用，无需手动调用；
     * 构造函数的名称和类名一致，无需返回值，不能有返回值类型，可以传入参数；
     */
    Person()
    {
        cout<< "构造函数被调用啦" <<endl;
        name = (char *)malloc(sizeof("偶买噶"));
        strcpy(name,"偶买噶");
        age = 20;
    }
    /**
     * @desc 析构函数用于对象销毁，对象销毁前系统会自动调用
     * 名称是类名前加上取反符号~，没有返回值，没有返回值类型，不能传参，不能重载
     */
    ~Person()
    {
        cout<< "析构函数调用啦，这个对象马上就没啦" <<endl;
        if(name != NULL){
            free(name);
            name = NULL;
        }
    }
public:
    char *name;
}
```
--------------------------------------------

构造函数分类
- 无参构造函数
- 有参构造函数
```c++
class Person{
public:
    Person(){
        age = 0;
    }
    Person(int a){
        age = a;
    }
private:
    int age;
}
void main()
{
    // 调用无参数构造函数
    Person per; // 此处不能用per()，否则报错

    // 调用有参构造函数
    Person per(100);    // 1、括号法
    Person(100);        // 2、匿名对象法，创建了一个匿名的对象；
    Person per = 100;   // 3、等号法，隐式转换，此句等价于Person per = Person(100)
}


```


- 普通构造函数
- 拷贝构造函数（复制构造函数）：使用另外一个对象初始化当前对象