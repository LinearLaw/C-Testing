# C++

```c++
// hello world
#include<iostream>      // 头文件引入
using namespace std;    // 规定使用标准命名空间

int main(){	
    // cout是C++标准输出流，endl是输出换行并刷新缓冲区
    // 两个放到一起，这句和printf效果一样
	cout << "hello world" << endl;
	return EXIT_SUCCESS;
}

```
面向过程思想核心：功能分解、自顶向下、逐层细化；  
> 程序 = 数据结构 + 算法    

面向对象思想核心：应对变化、提高复用；
> 对象 = 算法 + 数据结构    
> 程序 = 对象 + 对象 + 对象 + ...       

--------------------------------------------

面向对象三大特性    
- 封装：客观事物封装成抽象的类      
- 继承：类之间的相互关系
- 多态：一种接口，多种方法

## C++对C的扩展

- ::作用域运算符

————————————————————————————————————————————

- 命名空间namespace

————————————————————————————————————————————

- using声明：using之后就将目标命名空间内的变量都引入了

————————————————————————————————————————————

- 全局变量检测增强

————————————————————————————————————————————

- 更严格的类型检查

————————————————————————————————————————————

- 更严格的类型转换

————————————————————————————————————————————

- struct功能增强

————————————————————————————————————————————

- bool类型关键字

————————————————————————————————————————————

- 三目运算符功能增强
```c
/**
 * 可以放在赋值操作符左边的是左值，可以放到赋值操作符右边的是右值
 * 
 * 这里的a就是一个左值，10是一个右值
 * 左值就是可以重新给它赋值的东西，例如变量，是一个内存地址的引用
 * 右值就是一个值，不能给它重新赋值，它不是一个引用；
 * 
 * 有些变量可以做左值也可以做右值；
 */
int a = 10;
int b = a;
```
————————————————————————————————————————————

- const
```c
在c++中，一个const不必创建内存空间，
而在c中，一个const总是需要一块内存空间。

不过，取一个const地址, 或者把它定义为extern,则会为该const创建内存空间。

在C++中，出现在所有函数之外的const作用于整个文件，在该文件外不可见，
即默认为内部连接，C++中其他的标识符一般默认为外部连接。
```
**const在C和C++中的编译过程是不同的。**         
c中const默认为外部连接，c++中const默认为内部连接。      

宏常量是没有命名空间的。    
宏常量并不重视作用域，定义在当前文件任何位置都能访问到，或者是出现了#undef。      
宏常量没有类型，const有类型。       

————————————————————————————————————————————

- 引用（重点）  
```c
int a = 10;
int& b = a; // b作为a变量的别名，
```
注意：引用不可以有NULL，必须跟某一个存储单元关联；
引用必须要初始化，在定义的时候就必须要指向一个单元。      
并且一旦初始化就不可更改。  
可以对数组进行引用。    

```c
int& c; // 这种写法错误
int& d = a;
d = b; // 这个操作不允许

// 直接引用数组是不通过的
int arr[10];
int& ref[10] = arr;  // 本句报错；
```
如何对数组进行引用？    
```c
// 方法一：
typedef int ArrRef[10]; 
int arr[10];
ArrRef aRef = arr;
for(int i = 0;i<10;i++){
    aRef[i] = i+1;
};

// 方法二
int(&f)[10] = arr;
for (int i = 0; i < 10; i++){
	f[i] = i+10;
}
```
函数中的引用    
```c
// 函数传值
void ValueSwap(int m,int n){
	int temp = m;
	m = n;
	n = temp;
}
ValueSwap(a, b);

// 函数传指针
void PointerSwap(int* m,int* n){
	int temp = *m;
	*m = *n;
	*n = temp;
}
PointerSwap(&a, &b);

// 函数传引用
void ReferenceSwap(int& m,int& n){
	int temp = m;
	m = n;
	n = temp;
}
ReferenceSwap(a, b);

/*
显然，这三种方式，函数形参的写法不一样，调用时传值也不一样。
*/
```
```c
// 函数返回值为引用类型，不可以返回局部变量的引用
int& test()
{
    int a = 10;
    return a;   // 该行为不允许，不能局部变量的引用
}
// 函数当左值，必须返回引用
int& test1()
{
    int a = 20;
    return a;
}
test1() = 100;  // test1的返回值作为左值，此时需要返回引用才行；
```
引用的实质：引用的本质就是一个指针常量；
```c
// 以下两句等价
int* const a = &val;
int& a = val;
```

--------------------------------------------

指针引用
```c
struct Teacher
{
    int age;
}
// 使用指针修改结构体成员
void testPointer(Teacher** tc)
{
    *tc = (Teacher*)malloc(sizeof(Teacher));
    (*teacher)->age = 200;
}

// 使用引用修改结构体成员，传入一个结构体的指针引用
void test(Teacher*& tc)
{
    tc->age = 300;
}

```
--------------------------------------------
常量引用
```c
const int& ref = val;
```
注意：const修饰的引用不可修改；
```c
// 不能将一个字面量赋值给引用，下面这个操作不被允许
int& ref = 100;     // 报错

// 但是常量引用可以赋值，不会报错
const int& ref = 100;
```
> const引用的适用场景   
> - 函数的形参，比如复制、拷贝构造函数；    
> - 函数的形参定义为常量引用，不会产生新的变量，减少了传参的开销；  
> - 引用可能导致实参因为形参的改变而发生改变，常量引用可以避免这种情况；

————————————————————————————————————————————

- 内联函数
在C语言中，通常会把短而执行频繁的计算写成宏，也就是#define，在预处理的阶段，    
程序中的所有宏的引用都会被替换成宏的实际值，从而避免了函数调用的开销。  
但是有点问题，
> ①、宏隐藏了真正的变量值，会隐藏一些难以发现的错误；   
> ②、在C++中，预处理器不允许访问类的成员，也就是预处理器宏不能用作类的成员函数；    

为了解决这些问题，C++引入了内联函数；
```c
// 问题1
#define ADD(x,y) x+y
int ret1 = ADD(10,20) * 10; // 本来期望ret1是300的，结果发现却是210
// 原因，预处理阶段，这句变成了 int ret1 = 10+20*10，导致错误


int add(int x,int y)
{
    return x+y;
}
int ret2 = add(10,20) * 10; // ret2为300，正常的函数，不会有宏的那种问题
```
```c
// 问题2
#define COMPARE(x,y) ((x) < (y))?(x):(y);
int a = 1;
int b = 3;
int ret1 = COMPARE(++a , b);    // 本句结果为3，显然是错误的结果
// 原因，int ret1 = ((++a)<(b))?(++a):(b); 明显地，a被++了两次；


int compare(int x, int y)
{
    return x<y?x:y;
}
let ret2 = compare(++a,b);  //  本句结果2，正常的函数可以返回正确的结果
```
```
// 问题3，宏函数没有作用域的概念，无法作为一个类的成员函数；

```
内联函数，是一个真正的函数，具有普通函数的所有行为；
```c
// 在原本的函数类型前加上inline，即可定义一个内联函数；
// 但是注意，函数体和声明必须同时存在；
// 下面这句没有任何效果；
inline void func(int a);

// 正确的写法
inline void func(int a){return a;}
```
inline函数会在编译的时候像预定义宏一样展开，不占用调用函数的开销。      
注意：内联函数依然占用空间，但是相对于普通函数，内联函数省去了函数调用时的压栈、跳转、返回等开销，是一种以空间换时间的方式；    

注意：内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议；
要达成内联编译，需要具备以下条件：
> ①、不能存在任何形式的循环语句     
> ②、不能存在过多的条件判断语句     
> ③、函数体不能过于庞大     
> ④、不能对函数进行取址操作     

————————————————————————————————————————————

- 函数形参默认值
```c
void func(int a =10,int b = 20)
{

}

// 注意，函数默认参数从左到右，如果一个参数设置了默认参数，
//      那么这个参数之后的参数都必须设置默认参数
// 如果函数声明和定义分开，声明和定义中的默认值不能同时设置（要么声明里面写，要么定义里面写）
```
————————————————————————————————————————————
- 函数占位参数
```c
void func(int a, int b, int = 20)
{
    // 但是你无法在里面使用占位参数
}

// 那这玩意有啥用？答案是用于操作符重载
```
————————————————————————————————————————————

- 函数重载（overload）
