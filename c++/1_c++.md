# C++

```c++
// hello world
#include<iostream>      // 头文件引入
using namespace std;    // 规定使用标准命名空间

int main(){	
    // cout是C++标准输出流，endl是输出换行并刷新缓冲区
    // 两个放到一起，这句和printf效果一样
	cout << "hello world" << endl;
	return EXIT_SUCCESS;
}

```
面向过程思想核心：功能分解、自顶向下、逐层细化；  
> 程序 = 数据结构 + 算法    

面向对象思想核心：应对变化、提高复用；
> 对象 = 算法 + 数据结构    
> 程序 = 对象 + 对象 + 对象 + ...       

--------------------------------------------

面向对象三大特性    
- 封装：客观事物封装成抽象的类      
- 继承：类之间的相互关系
- 多态：一种接口，多种方法

## 1、C++对C的扩展

- ::作用域运算符

————————————————————————————————————————————

- 命名空间namespace
    - 基本用法：
```cpp
/* 1、game1 定义了一个LOL的命名空间  */
// game1.h
#include <iostream>
using namespace std;

namespace LOL{
    void GoAtk();
}
// game1.cpp
#include "game1.h"
void LOP::GoAtk(){
    cout << "LOL ATK" << endl;
}

// 调用
void main(){
    LOL::GoAtk();
}
```
Tips：一些注意事项
- 1、命名空间下可以放函数、变量、结构体、类
- 2、命名空间必须定义在全局作用域下
- 3、命名空间可以嵌套
```cpp
namespace A{
    int m_a = 100;
    struct Person{
        string name;
    }
    namespace B{
        int m_b = 10;
    }
}

// 访问
A::B::m_b
```

- 4、命名空间是开放的，可以随时往命名空间中加入内容

- 5、匿名命名空间
```cpp
namespace {
    int m_c = 0;
    int m_d = 0;
}
/**
 *  当写了无名命名空间，相当于写了 static int m_c; static int m_d;
 *  m_c、m_d 都只能在当前文件内使用
 */
static int m_c;
static int m_d;
```

- 6、命名空间可以起别名
```cpp
namespace NameA{
    int m_a = 0;
}
void test(){
    // 将NameA起别名，命名为NameB
    namespace NameB = NameA;
    cout << NameA::m_a << endl;
    cout << NameB::m_a << endl;
}
```

- 

————————————————————————————————————————————

- using声明：using之后就将目标命名空间内的变量都引入了

————————————————————————————————————————————

- 全局变量检测增强
```cpp
// 以下代码在C语言下编译成功，但在C++下会编译失败

int a;      // 没有赋值，则当做声明
int a = 10; // 有赋值
```

————————————————————————————————————————————

- 更严格的类型检查
```cpp
// C++中所有的变量和函数都必须要有类型

// 1、i没有类型，报错。
int fun1(i){
    return 0;
}

// 2、fun2是无参数函数，调用时传入了参数，报错。
int fun2(){
    return 0;
}
fun2(123);

// 3、int fun()和int fun(void)是相同的，都是无参数函数
int fun3(void){
    return 0;
}
```
————————————————————————————————————————————

- 更严格的类型转换
```cpp
// 以下C语言写法，在C++无法编译成功
typedef enum COLOR{
    GREEN,RED,YELLOW
} color;

int main(){
    color MyColor = GREEN;
    MyColor = 10;   // 枚举类型变成了 int 类型
    printf("MyColor:%d\n",MyColor);

    // malloc的返回值是void*类型，C里面可以直接转成char*，C++不行
    char* p = malloc(10);   
    return EXIT_SUCCESS;
}
```

————————————————————————————————————————————

- struct功能增强
    - C中的结构体只能定义成员变量，不能定义成员函数
    - C++中的结构体可以定义成员变量，也可以定义成员函数
```cpp
// 在C++中，结构体既可以定义成员变量，也可以定义成员函数
struct Student{
    string mName;
    int age;
    void ShowStudent(){

    }
}

// C++中定义结构体变量不需要加struct关键字
void test(){
    // C写法
    struct Student student;

    // C++写法
    Student student;
}
```
————————————————————————————————————————————

- bool类型关键字
    - bool类型只有两个值，1(true) 和 0(false)
```cpp
void test02(){
    bool flag = true;

    // 当给bool类型赋值时，非0的值都会变成1；0则会变成0；
    flag = 100;
}
```

————————————————————————————————————————————

- 三目运算符功能增强
```c
/**
 * 可以放在赋值操作符左边的是左值，可以放到赋值操作符右边的是右值
 * 
 * 这里的a就是一个左值，10是一个右值
 * 左值就是可以重新给它赋值的东西，例如变量，是一个内存地址的引用
 * 右值就是一个值，不能给它重新赋值，它不是一个引用；
 * 
 * 有些变量可以做左值也可以做右值；
 */
int a = 10;
int b = 20;
int c = a;

// 这里需要思考一个问题，三目运算符返回的是左值还是右值？
printf("ret: %d\n", a>b?a:b);

// (a>b?a:b) = 100
// 三目运算符 在C语言中，返回的是右值，是一个数
//      在C++中，三目运算符返回的是变量本身的引用，是一个左值。

// 下面这句，C中报错，C++不报错
(a>b?a:b) = 100;

```
————————————————————————————————————————————

- const
    - 尽量用const来替换#define
```c
/*
    在c++中，一个const不必创建内存空间，
    而在c中，一个const总是需要一块内存空间。

    不过，取一个const地址, 
    或者把它定义为extern,则会为该const创建内存空间。

    在C++中，出现在所有函数之外的const作用于整个文件，在该文件外不可见，
    即默认为内部连接，C++中其他的标识符一般默认为外部连接。

 */
```
**const在C和C++中的编译过程是不同的。**             

> - c中const默认为外部连接，c++中const默认为内部连接。      
> - 宏常量是没有命名空间的。    
> - 宏常量并不重视作用域，定义在当前文件任何位置都能访问到，或者是出现了#undef。      
> - 宏常量没有类型，const有类型。       

————————————————————————————————————————————

- 引用（重点）  

```c
int a = 10;
int& b = a; // b作为a变量的别名，
```

> 注意：引用不可以有NULL，必须跟某一个存储单元关联；  
> 引用必须要初始化，**在定义的时候就必须要指向一个单元**。       
> 并且一旦初始化就不可更改。  
> 可以对数组进行引用。    

```c
int& c; // 这种写法错误
int& d = a;
d = b; // 这个操作不允许

// 直接引用数组是不通过的
int arr[10];
int& ref[10] = arr;  // 本句报错；

```

如何对数组进行引用？   

```c
// 方法一：
typedef int ArrRef[10]; 
int arr[10];

ArrRef aRef = arr;
for(int i = 0; i<10 ; i++){
    aRef[i] = i+1;
}

// 方法二
int(&f)[10] = arr;
for (int i = 0; i < 10; i++){
	f[i] = i+10;
}
```

函数中的引用  

```c
// 函数传值
void ValueSwap(int m,int n){
	int temp = m;
	m = n;
	n = temp;
}
ValueSwap(a, b);

// 函数传指针
void PointerSwap(int* m,int* n){
	int temp = *m;
	*m = *n;
	*n = temp;
}
PointerSwap(&a, &b);

// 函数传引用
void ReferenceSwap(int& m,int& n){
	int temp = m;
	m = n;
	n = temp;
}
ReferenceSwap(a, b);

/*
显然，这三种方式，函数形参的写法不一样，调用时传值也不一样。
*/
```
```c
// 函数返回值为引用类型，不可以返回局部变量的引用
int& test()
{
    int a = 10;
    return a;   // 该行为不允许，不能局部变量的引用
}
// 函数当左值，必须返回引用
int& test1()
{
    int a = 20;
    return a;
}
test1() = 100;  // test1的返回值作为左值，此时需要返回引用才行；
```

**引用的实质：引用的本质就是一个指针常量；**

```c
// 以下两句等价
int* const a = &val;
int& a = val;
```

--------------------------------------------

指针引用
```c
struct Teacher
{
    int age;
}
// 使用指针修改结构体成员
void testPointer(Teacher** tc)
{
    *tc = (Teacher*)malloc(sizeof(Teacher));
    (*teacher)->age = 200;
}

// 使用引用修改结构体成员，传入一个结构体的指针引用
void test(Teacher*& tc)
{
    tc->age = 300;
}

```
--------------------------------------------
常量引用
```c
const int& ref = val;
```
注意：const修饰的引用不可修改；
```c
// 不能将一个字面量赋值给引用，下面这个操作不被允许
int& ref = 100;     // 报错

// 但是常量引用可以赋值，不会报错
const int& ref = 100;
```
> const引用的适用场景   
> - 函数的形参，比如复制、拷贝构造函数；    
> - 函数的形参定义为常量引用，不会产生新的变量，减少了传参的开销；  
> - 引用可能导致实参因为形参的改变而发生改变，常量引用可以避免这种情况；

————————————————————————————————————————————

- 内联函数
在C语言中，通常会把短而执行频繁的计算写成宏，也就是#define，在预处理的阶段，    
程序中的所有宏的引用都会被替换成宏的实际值，从而避免了函数调用的开销。  
但是有点问题，
> ①、宏隐藏了真正的变量值，会隐藏一些难以发现的错误；   
> ②、在C++中，预处理器不允许访问类的成员，也就是预处理器宏不能用作类的成员函数；    

为了解决这些问题，C++引入了内联函数；
```c
// 问题1
#define ADD(x,y) x+y
int ret1 = ADD(10,20) * 10; // 本来期望ret1是300的，结果发现却是210
// 原因，预处理阶段，这句变成了 int ret1 = 10+20*10，导致错误


int add(int x,int y)
{
    return x+y;
}
int ret2 = add(10,20) * 10; // ret2为300，正常的函数，不会有宏的那种问题
```
```c
// 问题2
#define COMPARE(x,y) ((x) < (y))?(x):(y);
int a = 1;
int b = 3;
int ret1 = COMPARE(++a , b);    // 本句结果为3，显然是错误的结果
// 原因，int ret1 = ((++a)<(b))?(++a):(b); 明显地，a被++了两次；


int compare(int x, int y)
{
    return x<y?x:y;
}
let ret2 = compare(++a,b);  //  本句结果2，正常的函数可以返回正确的结果
```
```
// 问题3，宏函数没有作用域的概念，无法作为一个类的成员函数；

```
内联函数，是一个真正的函数，具有普通函数的所有行为；
```c
// 在原本的函数类型前加上inline，即可定义一个内联函数；
// 但是注意，函数体和声明必须同时存在；
// 下面这句没有任何效果；
inline void func(int a);

// 正确的写法
inline void func(int a){return a;}
```
inline函数会在编译的时候像预定义宏一样展开，不占用调用函数的开销。      
注意：内联函数依然占用空间，但是相对于普通函数，内联函数省去了函数调用时的压栈、跳转、返回等开销，是一种以空间换时间的方式；    

注意：内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议；
要达成内联编译，需要具备以下条件：
> ①、不能存在任何形式的循环语句     
> ②、不能存在过多的条件判断语句     
> ③、函数体不能过于庞大     
> ④、不能对函数进行取址操作     

————————————————————————————————————————————

- 函数形参默认值
```c
void func(int a =10,int b = 20)
{

}

// 注意，函数默认参数从左到右，如果一个参数设置了默认参数，
//      那么这个参数之后的参数都必须设置默认参数
// 如果函数声明和定义分开，声明和定义中的默认值不能同时设置（要么声明里面写，要么定义里面写）
```
————————————————————————————————————————————
- 函数占位参数
```c
void func(int a, int b, int = 20)
{
    // 但是你无法在里面使用占位参数
}

// 那这玩意有啥用？答案是用于操作符重载
```
————————————————————————————————————————————

- 函数重载（overload）
> 实现函数重载，首先要满足同名函数在同一个作用域下，然后满足以下其中之一    
> - 参数个数不同    
> - 参数类型不同    
> - 参数顺序不同    

--------------------------------------------
```c++
namespace A{
    void func(){}
    void func(int a){}
    void func(string a){}
    void func(int a, string b){}
    void func(string a, int b){}
}
```
注意：两个同名函数，形参个数和类型一样，顺序一样，但是返回值不一样，    
函数的返回值不能作为重载的依据，因为C++编译器依然无法知道调用的时候到底调用的是哪个。   

--------------------------------------------

```c++
// 另外，如果使用了形参默认值，注意函数的二义性
namespace S{
    void func(string b){}
    void func(string b,int a = 10){}
}
func("hello");  // 此时，因为默认值的存在，C++编译器依然不知道调用的是哪个func
```
--------------------------------------------

重载是如何实现的？    
> 在C++编译的时候，同名的重载函数将会根据其形参特征重新命名，   
> 例如func(int x, char y)可能命名为_funcic      
> 例如func(int x)可能命名为_funci   
> 重命名的规则会依据编译平台的不同而不同。  

--------------------------------------------

extern "C"
> 因为重载编译重命名的影响，但是C编译不会出现重命名，这就会导致程序出错；   
> 因此需要为某一段代码单独设置以C语言方式进行编译和链接，因此就有了extern "C";      
>       
> **代码暂时不放了（有一丢丢长，之后再说，Todo list+1）**。    

--------------------------------------------

## 2、类和对象

struct结构体类型
> 在C语言中，struct中只有变量；     
> 在C++中，struct既有变量，也有函数；   

————————————————————————————————————————————

### 2.1、类
> C语言可以用结构体类型来描述某一个对象的各个属性，用函数来表示某个对象所具有的行为，   
> 但是这样有问题，某一个对象具有的行为不一定其他对象也具备，但是对于函数而言,它是不区分对象的，     
> 也就是说，我们需要将对象的属性和行为归到一起；    
> 另外，对象应该拥有不能被外界访问的私有属性和私有方法，只有对象自身才能访问；  

--------------------------------------------

- 封装
> 变量和属性合成整体，封装在一个类中，并对变量和函数进行访问控制；  

--------------------------------------------

- 访问权限控制
> 类的内部没有访问权限之分，所有成员可以互相访问；  
> 类的外部对类的内部，访问权限有三种：public, private, protected；  
> 类的外部，仅可访问类的public修饰的成员（此时先忽略继承与派生的情况）；     

> private和protected是同等级的，外部不允许访问。     
```c++
class Person
{   
    // 公有成员，外部可访问
    public:
        void say(){ cout << "这是一个Person类" << endl; }
    public:
        int high;

    // 以下为私有成员
    protected:
        int money;
    private:
        int age;
}

int main()
{
    Person p;
    p.money;    // 报错，私有成员不可访问
    p.say();    // 公共成员可以访问，打印出一句话

    return EXIT_SUCCESS;
}
```

> 注意，    
> class默认访问权限为private      
> struct默认的访问权限为public  
```c++
class ObjectA{ int age; }
struct ObjectB{ int age; }
int main()
{   
    // 创建两个对象
    ObjectA a;
    ObjectB b;
    a.age;  // 报错，class默认访问权限是private
    b.age;  // 可以访问
}
```
--------------------------------------------
将成员变量全部设置成private
> 将成员变量全部设置成private，然后用public的函数来对外提供访问内部成员的方法；     
> 这样的做法好处有很多，
> 1、当需要访问类成员时，全部通过函数来访问，无需考虑成员是public还是private；  
> 2、可以细分出内部变量的控制处理，例如进一步划分成只读不可写、不可读写，可读可写、只写不可读； 

--------------------------------------------
```c++
// 例、设计一个Person类

// 例、设计一个正方体类

// 例、设计一个线类和一个点类
```
###  2.2、对象构造和析构

对象创建出来之后，对象有一个初始状态，而当我们不需要这个对象时，需要将对象销毁。    

对象的初始化 → 构造函数     
对象的销毁 → 析构函数    

> 构造函数和析构函数会被编译器自动调用，完成对象的初始化和清理工作；    
> 所以编写类时，应该顺便提供初始化函数（不过不写初始化函数，编译器也会给你默认初始化）。    

--------------------------------------------

```c++
class Person{
public:
    /**
     * @desc 构造函数，创建对象时为对象的成员属性赋值，由编译器自动调用，无需手动调用；
     * 构造函数的名称和类名一致，无需返回值，不能有返回值类型，可以传入参数；
     */
    Person()
    {
        cout<< "构造函数被调用啦" <<endl;
        name = (char *)malloc(sizeof("偶买噶"));
        strcpy(name,"偶买噶");
        age = 20;
    }
    /**
     * @desc 析构函数用于对象销毁，对象销毁前系统会自动调用
     * 名称是类名前加上取反符号~，没有返回值，没有返回值类型，不能传参，不能重载
     */
    ~Person()
    {
        cout<< "析构函数调用啦，这个对象马上就没啦" <<endl;
        if(name != NULL){
            free(name);
            name = NULL;
        }
    }
public:
    char *name;
}
```
--------------------------------------------

构造函数分类
- 无参构造函数
- 有参构造函数
```c++
class Person{
public:
    Person(){
        age = 0;
    }
    Person(int a){
        age = a;
    }
private:
    int age;
}
void main()
{
    // 调用无参数构造函数
    Person per; // 此处不能用per()，否则报错

    // 调用有参构造函数
    Person per(100);    // 1、括号法
    Person(100);        // 2、匿名对象法，创建了一个匿名的对象；
    Person per = 100;   // 3、等号法，隐式转换，此句等价于Person per = Person(100)

    // 拷贝构造函数
    Person person1 = 100;
    Person person2 = person1; // 等价于Person person2 = Person(person1)
}
```
```c++
// 注意，不能用拷贝构造函数初始化匿名对象
class Teacher{
public:
    // 这里定义了两个构造函数，一个是普通的构造函数，另一个是拷贝构造函数
    Teacher(){

    }
    // 拷贝构造函数接收一个同类的引用，用外部的引用来初始化自身
    Teacher(const Teacher& teacher){}
}

void main(){
    Teacher t1;
    Teacher(t1); // 本句此时等价于Teacher t1，程序报错
}
```
- 普通构造函数
- 拷贝构造函数（复制构造函数）：使用另外一个对象初始化当前对象
> 拷贝构造函数的调用时机：  
> - 对象以值传递方式，传给函数的参数；  
> - 函数局部对象，以传值方式，从函数返回；  
> - 用一个对象初始化另一个对象；    

--------------------------------------------

深拷贝和浅拷贝

--------------------------------------------

初始化的特殊手法
```c++
// 普通的初始化方式
class Person{
public:
    Person(int a , int b){
        A = a;
        B = B;
    }
private:
    int A;
    int B;
}

// 使用初始化列表的方式初始化
class Person{
public:
    Person(int a , int b):A(a),B(b){
        // do other things
    }
private:
    int A;
    int B;
}
```
--------------------------------------------

类的成员可以是基本数据类型，也可以是对象，叫做对象成员。    

在类初始化时，调用构造函数，先按各个对象成员在定义当中的顺序，依次调用该对象的构造函数，对这些对象初始化，再去调用类本身的构造函数。    
也就是说，先调用的是对象成员的构造函数，在调用本身的构造函数；  
析构函数的调用顺序和构造函数相反；

###  2.3、explicit

explicit用于禁止通过构造函数进行的隐式转换，声明为explicit的构造函数不能在隐式转换中使用。  

> explicit用于修饰构造函数，防止其隐式转化。    
> explicit主要针对单一参数的构造函数。  

```c++
class Person{
public:
    explicit Person(int a){ b = a;}
private:
    int b
}
int main(){
    Person str(2);  // 本句正常

    Person str1 = "abcd"; // 因为有explicit存在，所以本句会报错；
}

```

### 2.4、动态对象

C语言中分配动态内存，可以用malloc，realloc，释放内存用free。    
但是操作十分复杂，有多复杂？    
这里先不详述（Todo list +1）。      

所以C++引入了new和delete。      
new：   
```c++
// C++中直接一个new
Person* p = new Person;
// 上面这一句，在C当中相当于:
Person* p = (Person*)malloc(sizeof(Person));
if(p == NULL){
	return 0;
}
person->Init();
```

delete：delete表达式，先调用了析构函数，然后释放了内存。delete需要一个对象的地址，仅适用于new创建出来的对象；   
```c++
class Person{
public:
    Person(){
        name = (char *)malloc(strlen("undefined") + 1);
        strcpy(name,"undefined");
    }
    ~Person(){
        if(name != NULL){
            delete name;    // 这个操作是有问题的，malloc申请的空间不应该用delete释放
            name = NULL;
        }
    }
}

void main(){
    Person p1 = new Person();

    delete p1; // 正确的使用delete是直接作用于new出来的对象；
}
```
--------------------------------------------

数组的new和delete
```c++
// 创建一个字符数组
char *str = new char[100];
// 创建一个整形数组
int *i = new int[100];
// 创建一个整形的数组，并初始化赋初值
int *arr = new int[10]{1,2,3,4,5,6,7,8,9,0};

delete[] str;
delete[] i;
delete[] arr;
```
注意，如果是创建一个对象数组，必须对数组中每一个对象调用构造函数。可以在栈上聚合初始化。
```c++
// 栈聚合初始化
Person p[] = {Person("jojo",30) , Person("dio",22)}

// 堆上的对象必须要提供构造函数
Person* woker = new Person[20];
```
--------------------------------------------
delete void*可能会出错；    
delete void*将会不执行析构函数，会导致可用内存减少。    

注意：malloc、free和new、delete不能混搭使用。   

--------------------------------------------
```c++
// 以下函数会报错
Person *p = new Person[10];
delete p;

/*
Person有10个对象，而delete只作用到了1个对象，因此另9个没有调用析构函数，
没有调用析构函数的对象，可能删除不全，因为析构没有被完全调用。
*/
// 正确的调用：必须让delete知道p指针指向的内存空间中存在一个数组大小的记录，所以用delete[]。
delete[] p;
```
new 之后发生了两件事：1、分配内存；2、调用构造函数；    
delete之后发生了两件事：1、执行析构函数；2、释放内存；  

new 里面有[]，则delete里面也应有[]；    

###  2.5、静态成员

static可以被修改，特征是在所有对象中共享的是一份数据。

```c++
class Person{
public:
    // 类的静态成员属性
    static int num;
private:
    static int other;
}

// 类外初始化，初始化的时候不加static;
int Person::num = 0;
int Person::other = 0;

int main(){
    // 1、可以通过类名直接访问static成员
    Person::num = 10;
    // 2、也可以通过对象访问静态成员
    Person p1,p2;
    p1.num = 200;

    // 3、注意，静态成员也有访问权限，类外不能访问私有成员，例如other就不可访问；
    p1.other = 200;
}
```
> 静态成员变量在类中声明，在类外定义。  
> 静态数据成员**不归属于任何一个Person下的对象**，所有由Person构造出来的对象都**共享**着一个static成员（也就是**静态数据只有一份**）；    
> 对象分配空间时，不包括静态成员所占空间；      

###  2.6、静态成员函数

> 静态成员函数**只能访问静态变量**，不能访问普通成员变量    
> 静态成员函数的使用和静态成员变量一样      
> 静态成员函数也有访问权限      
> 普通成员函数可访问静态成员变量、也可以访问非经常成员变量      

--------------------------------------------

const静态成员属性   
既要实现共享，又要实现不可改变，就要用static const修饰。    
定义静态const数据成员时，最好在类的内部初始化。     
const static的静态成员，初始化之后就只可读不可写了。    

--------------------------------------------

静态成员和单例模式

--------------------------------------------

