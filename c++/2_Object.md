##  3、面向对象

this指针：是一个指向本对象的指针，不会影响sizeof的结果。    
this指针永远指向当前对象，无需定义，隐含在每个类的非静态成员函数中。    

> 注意：静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。  

this 的使用
- 当形参和成员变量同名时，可用this指针来进行区分。  
- 在类的非静态成员函数中返回对象本身，可以return *this;

——————————————————————————————————————————————————————————      

const 修饰成员函数      
const修饰了成员函数时，const修饰的是this指针指向的内存区域，    
成员函数内部不可以修改本类中任何普通成员变量。  
但是，如果一个成员变量用了**mutable**修饰，就不受const限制，const修饰的函数可以修改mutable的值。        

——————————————————————————————————————————————————————————      

const修饰对象       

const修饰的常对象只能调用const的成员函数；  
常对象可以访问const或非const的数据成员，但是不能修改。  
**mutable**修饰的成员可以被const对象修改。  
——————————————————————————————————————————————————————————     

## 4、友元函数

使用友元函数，可以在类的外部访问类的私有成员。    
友元函数是一种特权函数，外部可以通过使用友元函数，来达到访问私有成员的目的。    

- friend关键字只出现在声明处
- 其他类、类成员函数、全局函数都可声明为友元
- 友元函数不是类的成员，**不带this指针**
- 友元函数**可访问对象任意成员属性**，包括私有属性

友元类
- 1．友元关系不能被继承。
- 2．友元关系是单向的，类A是类B的朋友，但类B不一定是类A的朋友。
- 3．友元关系不具有传递性。类B是类A的朋友，类C是类B的朋友，但类C不一定是类A的朋友。
——————————————————————————————————————————————————————————      

## 5、运算符重载（这个有点厉害啊）

运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。    

> 这是一种语法糖，是另一种函数调用的方式。

语法：operator@ （@表示被重载的运算符）

--------------------------------------------------      
自增++/自减--重载       

> ++和--的原理，其实就是利用了运算符重载。      
```c++
class Complex{

    public:
        // 重载++运算符 
        Complex& operator++(){
            a++;
            b++;
            return *this;
        }
    private:
        int a;
        int b;
}
void test(){
    Complex complex;

}
```
--------------------------------------------------      

指针运算符重载      
两个指针运算符：* ->    

--------------------------------------------------      

赋值运算符重载      
赋值运算符：=       

--------------------------------------------------      

等于和不等于(==、!=)运算符重载

--------------------------------------------------      

函数调用符号()重载

--------------------------------------------------      

注意：不要重载&&、||    
因为无法在这两种情况下实现内置操作符的完整语义。    
也就是说，&&，||的短路功能，使用函数实现会出错。    
另外再次强调：操作符重载其实是另一种形式的函数调用。    
```c++
class Complex{
    public:
        Complex(int flag){
            this->flag = flag;
        }
        Complex& operator+=(Complex& complex){
            this->flag = this->flag + complex.flag;
            return *this;
        }
        bool operator&&(Complex&& complex){
            return this->flag && complex.flag;
        }

    public:
        int flag;
}

int main(){
    Complex complex1(0);    // flag为0；
    Complex complex2(1);    // flag为1；

    /*
    正常的情况：从左往右算，左边complex1为假，那么立马退出运算，结果为假；
    重载之后的运算：complex1 +=complex2这个表达式会先计算，
        然后complex1的flag就变成了complex1+complex2，即1；
        于是判断语句complex1 && (complex1 += complex2)，得到了一个真；
    */
    if(complex1 && (complex1 += complex2)){
        cout <<"真"<<endl;
    }else{
        cout <<"假"<<endl;
    }
    return EXIT_SUCCESS;
}

// 原因：&& 和 ||的运算是从左往右，而重载后的运算会先将左右都计算完，再进行比较运算
```
--------------------------------------------------      

结论：
- =, [], () 和 -> 只能通过成员函数进行重载 
- << 和 >>只能通过全局函数配合友元函数进行重载 
- 重载 && 和 || 操作符无法实现，因为无法实现短路规则

--------------------------------------------------      

——————————————————————————————————————————————————————————      

## 6、继承和派生

有一个类A和类B，而类B具有类A的成员，但是B又有自己的成员。   
那么B就可以通过继承来获得A的成员。

```c++
// 【不使用继承时，在成员相互交集的类与类之间，需要写重复代码】
// 一个页面类
class Page{
    public:
        void header(){}
        void body(){}
        void section(){}
        void footer(){}
    private:
        string title;
}
// 另一个新闻页面类，具有Page所有的成员，如果不用继承，就要重写一遍Page的成员
class NewsPage{
    public:
        void header(){}
        void body(){}
        void section(){}
        void footer(){}
        void mainBody(){}   // NewPage自己特有的成员
    private:
        string title;

}
```
```c++
// 【使用继承】
// 此时，定义NewsPage时只需要定义其特有的成员即可，其他都从Page里面继承
class NewsPage:public Page{
public:
    void mainBody(){} 
}
```
B类**继承**于A类，也可以称作A类**派生**B类。        
> 一个子类是父类的继承，而父类派生出的是子类。      
> A就是基类，也称为父类；   
> B就是派生类，也称子类；       

语法：
```c++
class 派生类名：继承方式 基类名{
    // 这里就写 派生类自己独有的数据成员和函数成员；
}
```
三种继承方式：
- public：公有继承
- private：私有继承
- protected：保护继承

> 不同的继承方式会导致对基类成员的不同访问权限。      
> 派生类无法访问基类的私有属性；    

|       公有派生       |      私有派生      |     保护派生     |        
|-------------------|-------------------|-----------------|     
| 基类的保护属性变为保护属性 | 保护 → 私有 | 保护 → 保护 |      
| 公有属性还是公有属性 | 公有 → 私有 | 公有 → 保护 |    

```c++
class A{
    public:int a;
    protected:int b;
    private:int c;
}
// 公有继承：公有 → 公有，保护 → 保护
class B:public A
{
    public:int a;
    protected:int b;
    不可访问: int c;
}
// 保护继承：公有 → 保护，保护 → 保护
class B:protected A
{
    protected: int a;int b;
    不可访问: int c;
}
// 私有继承：公有 → 私有，保护 → 私有
class B:private A
{
    private: int a;int b;
    不可访问: int c;
}
```
--------------------------------------------------      

继承中的对象模型
> 在C++编译器的内部，对象可以理解为结构体，子类是由父类成员叠加子类新成员而成；     

--------------------------------------------------      

继承中的构造和析构
> 子类对象在创建时，先调用父类的构造函数，在调用子类的构造函数；          
> 如果父类构造函数有参数，需要在子类初始化列表中显示调用父类构造函数；      
>       
> 析构的顺序和构造相反，先析构子类，再析构父类；

如果是子类有对象成员时，先构造父类，再构造子类的对象成员，再构造子类；  
析构则相反；
--------------------------------------------------      

继承中的同名问题    
子类成员和父类成员同名，子类依然会从父类继承同名成员。      
子类访问这个成员时，默认访问子类自己的成员。    
如果要访问父类的这个成员，用作用域 :: 进行区分。
```c++
class Base{
    public:
        Base():mp(0){}
        void print(){ cout<<mp<<endl; }
    public:
        int mp;
}
// 使用mp访问到的是派生类的mp成员
// 使用Base::mp可以访问到基类的mp成员
class Derived:public Base{
    public:
        Derived:mp(10){}
        void print(){
            cout<< Base::mp <<endl;
            cout<< mp <<endl;
        }
        int& getBaseMp(){return Base::mp;}
    public:
        int mp;
}
```

> 如果在构造函数中，重新定义基类中的一个重载函数，在新类中所有其他版本将被自动隐藏；    

--------------------------------------------------      

非自动继承的函数

> 构造函数和析构函数是不会被继承的，必须为每一个派生类分别创建。
> operator=也不会被继承

--------------------------------------------------      

静态成员继承    
静态成员函数不能是虚函数。      

父类里有一个函数void a，形参1个，   
子类里定义了一个函数static void a，形参2个，那么，此时父类的a函数会被隐藏。

--------------------------------------------------      

多继承：从多个类当中继承。  
> 多继承会出现很多问题，    
> 例如函数、变量的大量重名。      
> 例如，派生对象去访问同名函数，会有二义性，此时不知道应该调用哪个基类中的同名函数。    
```c++
// D类同时继承自B和A
class D:public B,public A{

}
```

--------------------------------------------------      

菱形继承
派生类A、B，继承同一个基类C，而有一个派生类D又同时继承了A、B，成为菱形继承。    
同一个数据成员，D既继承了A，又继承了B，数据继承了两份，而显然D只需要一份，这就造成了重复继承的问题。    

C++因此引入了虚基类的概念。
```c++
class C{
    public:
        int mp;
}
class A:virtual public C{};
class B:virtual public C{};

class D:public A,public B{};

// 通过虚基类，D继承了来自C的mp，而不是来自A、B的mp
// C被称为虚基类。
// 在这种情况下，A、B、D三者共享了一份C的mp数据
```
在虚继承中，虚基类是被共享的，在继承体系中，无论被继承了多少次，对象内存模型中都只会出现一个虚基类的子对象，而多继承当中会出现多个。    

每一次的继承，C++都会调用基类的构造。   
而对于虚继承，只有在最后的子类继承中，C++才会调用基类的构造，其他初始化语句都不会调用。

> 对于没有公共基类的多继承，虚继承无法解决。    
> **实际开发中，多继承基本不用，因为维护很困难。**

## 7、多态

面向对象程序设计中，抽象、继承。多态，是三大特征。      
多态性，提供接口与具体实现之间的另一层隔离，C++支持编译时多态（静态多态）和运行时多态（动态多态）。     

运算符重载和函数重载就是**编译多态**。  
派生类和虚函数实现**运行时多态**。  

静态多态和动态多态，区别就是函数地址是早绑定（静态联编）还是晚绑定（动态联编）  
> 编译阶段，就可以确定函数调用地址，并产生代码 → 静态多态，即编译时多态     
> 函数调用地址在运行的时候才能决定 → 晚绑定，动态多态，运行时多态   

> 面向对象程序设计的一个基本原则：对修改关闭，对扩展开放；

--------------------------------------------------      

向上类型转换    

```c++
class Animal{
    public:
        void speak(){
            cout <<"动物在唱歌"<<endl;
        }
}
class Dog:public Animal{
    public:
        void speak(){
            cout <<"小狗在唱歌"<<endl;
        }
}
// Do传入的是一个Animal的引用
void Do(Animal& animal){
    animal.speak();
}
void test(){
    Dog d;
    Do(d);  // 此时，期望的打印是狗唱歌，结果却打印了动物在唱歌。
}
```
对象可以作为自己的类或者作为它的基类的对象来使用，还能通过基类的地址来操作它。      
取一个对象的地址(指针或引用)，并将其作为基类的地址来处理，  
这种称为向上类型转换。  

也就是说：**父类引用或指针**可以指向子类对象，通过父类指针或引用来操作子类对象。    

上面例子是由于早绑定造成的，编译代码时，根据指向对象的指针或引用类型来选择函数调用，而Do的参数是Animal的引用，编译器就会认为此时传入的应该调用的是Animal的speak，而不是Dog的speak。     

要解决这个问题，就要进行动态绑定，也就是绑定要根据对象的实际类型决定，在运行代码的时候才绑定。      

所以就有了虚函数（Vitual function）。   

--------------------------------------------------      

虚函数允许子类（派生类）重新定义父类（基类）成员函数，  
而子类（派生类）重新定义父类（基类）虚函数的做法称为覆盖(override)，或者称为重写。  

对于特定的函数进行动态绑定，c++要求在基类中声明这个函数的时候使用virtual关键字，动态绑定也就对virtual函数起作用。   

- 如果一个函数在基类中被声明为virtual，那么在所有派生类中它都是virtual的；
- 在派生类中virtual函数的重定义称为重写(override)；
- Virtual关键字只能修饰成员函数；
- 构造函数不能为虚函数；
```c++
class Animal{
    public:
        virtual void speak(){
            cout <<"AAAAAA"<<endl;
        }
}
class Dog:public Animal{
    public:
        virtual void speak(){
            cout <<"BBBB"<<endl;
        }
}

void Do(Animal& animal){
    animal.speak();
}

void test(){
    Dog d;
    Do(d); // 此时会打印正确的BBBB
}
```
--------------------------------------------------      

抽象类
在基类中，加入至少一个纯虚函数，这个基类就叫做抽象类。      

抽象基类只提供接口，而并没有实际的创建一个基类对象。    
- 虚函数用virtual，并在函数后面加上=0。
- 不能试图去实例化一个抽象类。
- 继承抽象类的时候，必须实现其所有的纯虚函数，否则派生类也是一个抽象类。
- 为啥要有抽象类，目的是将子类公共操作都抽象出来，通过一个公共接口操纵一组类。
```c++
// 1、定义一个抽象类
class Make{
public:
    // 定义纯虚函数，此时Make就是一个抽象类
    virtual void Boil()=0;
    virtual void Brew()=0;

    // 抽象类里面的非虚函数用来规定虚函数的执行流程之类的东西
    void MakeDrink(){
        Boil();
        Brew();
    }
}
// 2、定义一个类，派生自抽象类
class Coffee:public Make{
public:
    // 在派生类中，对于抽象类的虚函数必须要重写为新的实际的函数
    virtual void Boil(){
        cout <<"哦哦噢噢噢哦哦"<< endl;
    }
    virtual void Brew(){
        cout <<"wowowowoow"<< endl;
    }
}
// 业务函数
void DoBussiness(Make* drink){
    drink->MakeDrink();
    delete drink;
}

void test(){
    DoBussiness(new Coffee);
}
```

————————————————————————————————————————————————————————        

虚析构函数  
纯虚析构函数必须要有一个函数体。    
带有纯虚析构函数的基类，是一个抽象类，不能拿来创建基类对象。    

```c++
// 非纯虚析构函数，此时的基类不算是一个抽象类
class A{
public:
    virtual ~A();
}
A::~A(){}

// 纯虚析构函数，此时B基类是一个抽象类。
class B{
public:
    virtual ~B()=0;
}

A a; // A可以创建实例化对象；
B b; // B不能创建实例化对象，因为B是一个抽象类。
```
> 虚析构函数主要是为了实现多态。    
> 如果不需要实现多态，可以不用声明虚析构函数。      

————————————————————————————————————————————————————————        

重写、重载、冲定义

- 重载：是指的同一个作用域下的同名函数      
> 函数形参个数、形参类型、形参顺序都可以作为重载条件，const也可以作为重载条件，而函数return值不能作为重载条件。  
> 重载的各个函数都在同一个作用域下。

--------------------------------------------------      

- 重写：是覆盖，在继承当中，子类重写父类的virtual函数
> 注意：重写当中，函数返回值，函数名字，函数参数，必须和基类中的虚函数一致。    

--------------------------------------------------      

- 重定义：是隐藏，在继承当中，子类重新定义了父类的同名成员，此时父类的这个成员就被隐藏了。  

————————————————————————————————————————————————————————        

指向成员变量的指针
指针无需跟具体的成员变量关联，只需要跟基类关联即可；    

```c++
int A::*p; // 定义了一个指向A类中p成员的指针；

int A::*p = &A::pa; // 为成员变量指针初始化；

A a;
a.*p;
a->pa;
```
————————————————————————————————————————————————————————        
指向静态成员的指针
和指向成员变量的指针差不多，定义时无需跟类关联。
```c++
class A{
public:
    static void dis(){
        cout <<data<<endl;
    }
    static int data;
}

int A::data = 100;

void test(){
    int *p = &A::data; // 用指针直接执行静态成员函数

    void(*pfunc)() = &A::dis; // 将函数指针赋值给void指针
    pfunc();    // 借助指针执行函数
}
```

