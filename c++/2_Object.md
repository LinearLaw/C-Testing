##  3、面向对象

this指针：是一个指向本对象的指针，不会影响sizeof的结果。    
this指针永远指向当前对象，无需定义，隐含在每个类的非静态成员函数中。    

> 注意：静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。  

this 的使用
- 当形参和成员变量同名时，可用this指针来进行区分。  
- 在类的非静态成员函数中返回对象本身，可以return *this;

——————————————————————————————————————————————————————————      

const 修饰成员函数      
const修饰了成员函数时，const修饰的是this指针指向的内存区域，    
成员函数内部不可以修改本类中任何普通成员变量。  
但是，如果一个成员变量用了**mutable**修饰，就不受const限制，const修饰的函数可以修改mutable的值。        

——————————————————————————————————————————————————————————      

const修饰对象       

const修饰的常对象只能调用const的成员函数；  
常对象可以访问const或非const的数据成员，但是不能修改。  
**mutable**修饰的成员可以被const对象修改。  
——————————————————————————————————————————————————————————     

## 4、友元函数

使用友元函数，可以在类的外部访问类的私有成员。    
友元函数是一种特权函数，外部可以通过使用友元函数，来达到访问私有成员的目的。    

- friend关键字只出现在声明处
- 其他类、类成员函数、全局函数都可声明为友元
- 友元函数不是类的成员，**不带this指针**
- 友元函数**可访问对象任意成员属性**，包括私有属性

友元类
- 1．友元关系不能被继承。
- 2．友元关系是单向的，类A是类B的朋友，但类B不一定是类A的朋友。
- 3．友元关系不具有传递性。类B是类A的朋友，类C是类B的朋友，但类C不一定是类A的朋友。
——————————————————————————————————————————————————————————      

## 5、运算符重载（这个有点厉害啊）

运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。    

> 这是一种语法糖，是另一种函数调用的方式。

语法：operator@ （@表示被重载的运算符）

--------------------------------------------------      
自增++/自减--重载       

> ++和--的原理，其实就是利用了运算符重载。      
```c++
class Complex{

public:
    // 重载++运算符 
    Complex& operator++(){
        a++;
        b++;
        return *this;
    }
private:
    int a;
    int b;
}
void test(){
    Complex complex;

}
```
--------------------------------------------------      

指针运算符重载      
两个指针运算符：* ->    

--------------------------------------------------      

赋值运算符重载      
赋值运算符：=       

--------------------------------------------------      

等于和不等于(==、!=)运算符重载

--------------------------------------------------      

函数调用符号()重载

--------------------------------------------------      

注意：不要重载&&、||    
因为无法在这两种情况下实现内置操作符的完整语义。    
也就是说，&&，||的短路功能，使用函数实现会出错。    
另外再次强调：操作符重载其实是另一种形式的函数调用。    
```c++
class Complex{
public:
    Complex(int flag){
        this->flag = flag;
    }
    Complex& operator+=(Complex& complex){
        this->flag = this->flag + complex.flag;
        return *this;
    }
    bool operator&&(Complex&& complex){
        return this->flag && complex.flag;
    }

public:
    int flag;
}

int main(){
    Complex complex1(0);    // flag为0；
    Complex complex2(1);    // flag为1；

    /*
    正常的情况：从左往右算，左边complex1为假，那么立马退出运算，结果为假；
    重载之后的运算：complex1 +=complex2这个表达式会先计算，
        然后complex1的flag就变成了complex1+complex2，即1；
        于是判断语句complex1 && (complex1 += complex2)，得到了一个真；
    */
    if(complex1 && (complex1 += complex2)){
        cout <<"真"<<endl;
    }else{
        cout <<"假"<<endl;
    }
    return EXIT_SUCCESS;
}

// 原因：&& 和 ||的运算是从左往右，而重载后的运算会先将左右都计算完，再进行比较运算
```
--------------------------------------------------      

结论：
- =, [], () 和 -> 只能通过成员函数进行重载 
- << 和 >>只能通过全局函数配合友元函数进行重载 
- 重载 && 和 || 操作符无法实现，因为无法实现短路规则

--------------------------------------------------      

——————————————————————————————————————————————————————————      

## 6、继承和派生

有一个类A和类B，而类B具有类A的成员，但是B又有自己的成员。   
那么B就可以通过继承来获得A的成员。

```c++
// 【不使用继承时，在成员相互交集的类与类之间，需要写重复代码】
// 一个页面类
class Page{
public:
    void header(){}
    void body(){}
    void section(){}
    void footer(){}
private:
    string title;
}
// 另一个新闻页面类，具有Page所有的成员，如果不用继承，就要重写一遍Page的成员
class NewsPage{
public:
    void header(){}
    void body(){}
    void section(){}
    void footer(){}
    void mainBody(){}   // NewPage自己特有的成员
private:
    string title;

}
```
```c++
// 【使用继承】
// 此时，定义NewsPage时只需要定义其特有的成员即可，其他都从Page里面继承
class NewsPage:public Page{
public:
    void mainBody(){} 
}
```
B类**继承**于A类，也可以称作A类**派生**B类。        
> 一个子类是父类的继承，而父类派生出的是子类。      
> A就是基类，也称为父类；   
> B就是派生类，也称子类；       

语法：
```c++
class 派生类名：继承方式 基类名{
    // 这里就写 派生类自己独有的数据成员和函数成员；
}
```
三种继承方式：
- public：公有继承
- private：私有继承
- protected：保护继承

> 不同的继承方式会导致对基类成员的不同访问权限。      
> 派生类无法访问基类的私有属性；    

|       公有派生       |      私有派生      |     保护派生     |        
|-------------------|-------------------|-----------------|     
| 基类的保护属性变为保护属性 | 保护 → 私有 | 保护 → 保护 |      
| 公有属性还是公有属性 | 公有 → 私有 | 公有 → 保护 |    

```c++
class A{
    public:int a;
    protected:int b;
    private:int c;
}
// 公有继承：公有 → 公有，保护 → 保护
class B:public A
{
    public:int a;
    protected:int b;
    不可访问: int c;
}
// 保护继承：公有 → 保护，保护 → 保护
class B:protected A
{
    protected: int a;int b;
    不可访问: int c;
}
// 私有继承：公有 → 私有，保护 → 私有
class B:private A
{
    private: int a;int b;
    不可访问: int c;
}
```
--------------------------------------------------      

继承中的对象模型
> 在C++编译器的内部，对象可以理解为结构体，子类是由父类成员叠加子类新成员而成；     

--------------------------------------------------      

继承中的构造和析构
> 子类对象在创建时，先调用父类的构造函数，在调用子类的构造函数；          
> 如果父类构造函数有参数，需要在子类初始化列表中显示调用父类构造函数；      
>       
> 析构的顺序和构造相反，先析构子类，再析构父类；

如果是子类有对象成员时，先构造父类，再构造子类的对象成员，再构造子类；  
析构则相反；
--------------------------------------------------      

继承中的同名问题    
子类成员和父类成员同名，子类依然会从父类继承同名成员。      
子类访问这个成员时，默认访问子类自己的成员。    
如果要访问父类的这个成员，用作用域 :: 进行区分。
```c++
class Base{
public:
    Base():mp(0){}
    void print(){ cout<<mp<<endl; }
public:
    int mp;
}
// 使用mp访问到的是派生类的mp成员
// 使用Base::mp可以访问到基类的mp成员
class Derived:public Base{
public:
    Derived:mp(10){}
    void print(){
        cout<< Base::mp <<endl;
        cout<< mp <<endl;
    }
    int& getBaseMp(){return Base::mp;}
public:
    int mp;
}
```

> 如果在构造函数中，重新定义基类中的一个重载函数，在新类中所有其他版本将被自动隐藏；    

--------------------------------------------------      

非自动继承的函数

> 构造函数和析构函数是不会被继承的，必须为每一个派生类分别创建。
> operator=也不会被继承

--------------------------------------------------      

静态成员继承    
静态成员函数不能是虚函数。      

父类里有一个函数void a，形参1个，   
子类里定义了一个函数static void a，形参2个，那么，此时父类的a函数会被隐藏。

--------------------------------------------------      

多继承：从多个类当中继承。  
> 多继承会出现很多问题，    
> 例如函数、变量的大量重名。      
> 例如，派生对象去访问同名函数，会有二义性，此时不知道应该调用哪个基类中的同名函数。    
```c++
// D类同时继承自B和A
class D:public B,public A{

}
```

--------------------------------------------------      

菱形继承
派生类A、B，继承同一个基类C，而有一个派生类D又同时继承了A、B，成为菱形继承。    
同一个数据成员，D既继承了A，又继承了B，数据继承了两份，而显然D只需要一份，这就造成了重复继承的问题。    

C++因此引入了虚基类的概念。
```c++
class C{
    public:
        int mp;
}
class A:virtual public C{};
class B:virtual public C{};

class D:public A,public B{};

// 通过虚基类，D继承了来自C的mp，而不是来自A、B的mp
// C被称为虚基类。
// 在这种情况下，A、B、D三者共享了一份C的mp数据
```
在虚继承中，虚基类是被共享的，在继承体系中，无论被继承了多少次，对象内存模型中都只会出现一个虚基类的子对象，而多继承当中会出现多个。    

每一次的继承，C++都会调用基类的构造。   
而对于虚继承，只有在最后的子类继承中，C++才会调用基类的构造，其他初始化语句都不会调用。

> 对于没有公共基类的多继承，虚继承无法解决。    
> **实际开发中，多继承基本不用，因为维护很困难。**

## 7、多态

面向对象程序设计中，抽象、继承。多态，是三大特征。      
多态性，提供接口与具体实现之间的另一层隔离，C++支持编译时多态（静态多态）和运行时多态（动态多态）。     

运算符重载和函数重载就是**编译多态**。  
派生类和虚函数实现**运行时多态**。  

静态多态和动态多态，区别就是函数地址是早绑定（静态联编）还是晚绑定（动态联编）  
> 编译阶段，就可以确定函数调用地址，并产生代码 → 静态多态，即编译时多态     
> 函数调用地址在运行的时候才能决定 → 晚绑定，动态多态，运行时多态   

> 面向对象程序设计的一个基本原则：对修改关闭，对扩展开放；

--------------------------------------------------      

向上类型转换    

