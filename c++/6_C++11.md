# C++11新特性

## 1、Lambda表达式

作用：提供类似匿名函数特性
格式：[capture] (params) opt -> ret{body;}

- capture， 捕获列表：在函数内部可以使用哪些局部变量
- params， 参数表（可选）
- opt，函数选项，有三个值可以选择
    - mutable，lambda表达式内部的代码，可以修改被捕获的变量，且可以访问被捕获对象的non-const方法
    - exception，来说明lambda表达式是否抛出异常，以及抛出何种异常
    - attribute，用来声明属性

- ret，返回值属性，即拖尾返回值类型
- body，函数体


### 1.1、capture
捕获列表，lambda表达式的捕获列表，      
精细控制了lambda表达式能够访问的外部变量，以及如何访问这些变量      

- []  不捕获任何变量

- [&] 捕获外部作用域中所有变量，并作为引用，在函数体中使用->引用捕获

- [=] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）
    - 捕获的前提是变量可以拷贝
    - 捕获的变量在lambda表达式被创建的时候就拷贝了
        - 这意味着，如果后面变量值变更，lambda内的该变量不会变更；
    - 如果希望调用时即时访问外部变量 -> 用引用方式捕获

```cpp
int a = 0;
auto f = [=] { return a;};

a+=1;
cout << f() << endl;  // 此时输出0，因为是按值捕获
```
```cpp
int a = 0;
auto f = [&a] {return a;};

a+=1;
cout << f() <<endl; // 此时输出1，引用捕获
```

- [=,&foo]  按值捕获外部作用域中所有变量，并引用捕获foo变量

- [bar] 按值捕获bar变量，同时不捕获其他变量

- [this] 捕获当前类中的this指针，让lambda表达式具有和当前类成员函数同样的访问权限；
    - 如果使用了&和=，会默认添加this；
    - 捕获this之后，可以在lambda中使用当前类的成员变量和成员函数；

```cpp
class A{
public:
    int i = 0;
    void func(int x, int y){
        auto x1 = [] {return i;}  // 报错，没有捕获变量，不能访问i

        auto x2 = [=]{return i + x + y;}; // 正确
        auto x3 = [&]{return i + x + y;}; // 正确

        auto x4 = [this]{return i;}; // 正确
        auto x5 = [this]{return i+x+y;}; // 报错，因为x和y并没有设置捕获

        auto x6 = [this,x,y] {return i+x+y;}; // 正确
        auto x7 = [this]{return i++;}; // 正确
    }
}
```
```cpp
int a = 0,b = 1;

/*
    下面这句报错，lambda里面的a，是从外面的a复制而来
        但是，如果要修改这个复制后的a，需要加mutable关键字
*/
auto f4 = [=] {return a++;}

// 下面语句正确
auto f5 = [=] () mutable {return a++;}
```

### 1.2、Lambda的大致原理

- 定义一个lambda表达式，
    - 编译器自动生成一个匿名类，这个类重载了()运算符，称为闭包类型

- 运行时，lambda表达式返回一个匿名的闭包实例，该实例是一个右值
    - 所以上面的lambda表达式的结果，就是一个闭包；

- 如果设置复制传值捕获方式，类中会相应添加对应类型的非静态数据成员。
    - 运行时，使用复制的值初始化这些成员变量，从而生成闭包；

- 如果设置引用捕获方式，无论是否标记mutable，都可以在lambda表达式中修改捕获的值；
    - 闭包类中是否有对应的成员 -> 不确定，和具体的实现有关；

------------------------        

Tips：lambda表达式是不能被赋值的
```cpp
auto a = []{ cout << "A" << endl;};
auto b = []{ cout << "b" << endl;};

a = b;  // 报错，lambda表达式的结果，是一个右值，无法被赋值
auto c = a ; // 正确，此时生成了一个a的副本

```
------------------------        

Tips：闭包类型，禁用了赋值操作符，但是没有禁用复制构造函数，    
    所以，可以用一个lambda表达式初始化另一个lambda表达式；      

------------------------

Tips：在多种捕获方式中，最好不要使用[=]和[&]默认捕获所有变量
```cpp
/*
    在这里，int x 在add_x被调用后就会被销毁，
    但是返回的lambda表达式却引用了这个x，
    当调用这个表达式时，x是一个野指针，指向已被释放的地址，这个引用是一个垃圾值
    这种引用悬挂，会导致野指针问题；

    所以推荐用默认传值方式 -> [=]
*/
std::function<int(int)> add_x(int x){
    return [&](int a){return x+a;}
}

/*
    但是，默认传值方式，也可能会产生问题 -> 其实这里不太明白

    下面的这个lambda，捕捉到的divisor，其实并不可见
*/
class Filter{
public:
    Filter(int divisorVal): divisor{divisorVal}{}

    std::function<bool(int)> getFilter(){
        // 这里引用的divisor，其实是一个指针，此时也产生了引用悬挂的问题；
        return [=](int value){return value % divisor  == 0;};
    }

    std::function<bool(int)> getFilter(){
        // 实际上，捕捉到的this，是外部this指针的副本；
        return [this](int value){return value% this->divisor==0;};
    }
private:
    int divisor;
}
```
------------------------    

lambda表达式的一个重要引用：可以用于函数的参数，实现回调函数
```cpp
// 1、例如，
// count_if，从vector容器中筛选，第三个参数可以传入一个函数，用来指定筛选条件
int value = 3;
vector<int> v{1,2,3,45,342,3423};
int count = std::count_if(
    v.begin(),
    v.end(),
    [value](int x){return x>value;}  // 筛选条件，使用一个匿名函数
);

// 2、例如
// 斐波那契数列的生成，使用generate函数，生成后直接存入vector中
vector<int> v(10);
int a = 0;
int b = 1;
std::generate(
    v.begin(),
    b.end(),
    [&a,&b]{
        int value = b;
        b = b + a;
        a = value;
        return value;
    }
);

// 3、例如，遍历容器，统一操作
std::vector<int> v = {1,24,34,243,2,645};
int even_count = 0;
for_each(
    v.begin(),
    v.end(),
    [&even_count](int val){
        if(!val & 1){
            ++ even_count;
        }
    }
);
std::cout << even_count << std::endl;
```
