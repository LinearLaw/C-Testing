# Vol.09

## 9.1、内部类（内置类、嵌套类）

将一个类，定义在另一个类的内部，就变成了内部类。    
内部类可以方位外部类中的所有成员，包括private。     
外部类无法直接访问内部类，要new之后才能访问。   

——————————————————————————————————————————      

## 9.2、内部类访问规则

#### 如何直接访问一个内部类成员？

```java
Outer.Inner in = new Outer().new Inner();
in.function();
```

> 一般的，Inner类会被设置成private

```java
x
this.x      // 访问内部类的x
Outer.this.x    // 访问外部类成员x
```

> 之所以可以访问外部类成员，是因为内部类中有外部类的引用。  

——————————————————————————————————————————      

## 9.3、访问规则

### 1、内部类非私有，那么在其他类中可以用 外部类.内部类 访问
```java
Outer.Inner in = new Outer.new Inner();
```

内部类在成员位置上，就可以被成员修饰符修饰。    

——————————————————————————————————————————      

### 2、内部类static之后，就只能访问外部类中的static成员。  
```java
// function是Inner类的一个static成员
new Outer.Inner().function();  

// 上面的代码和下面的代码等价。

// oter是一个Outer的实例，function是一个Inner类的static成员
oter.Inner.function();
```

> 注意：    
> 当内部类中定义了静态成员，该内部类必须是static的，    
> 如果外部类中的静态方法，去访问内部类，那么这个内部类也必须要static    

——————————————————————————————————————————      

### 3、描述事物内部还有事物，就可以用内部类。   
内部事物使用了外部事物的内容。  

> 这是一种关系映射的设计。  

——————————————————————————————————————————      

### 4、内部类定义在局部中时，

比如，一个function函数，里面有一个内部类。  

- 1）不可以被成员修饰符修饰
- 2）可以直接访问外部类中的成员，因为这个内部类里面有外部类的引用。
    - 但是，不可以访问它所在的局部中的变量，
    - 只能访问被final修饰的局部变量
```java
class Outer
{
    int x = 3;
    void method(final int a){
        // 1、method函数有一个a，有一个y，都用final修饰
        // 那么，Inner内部的函数就可以访问这两个变量。
        final int y = 4;
        int s = 5;

        // 2、Inner可以访问x，可以访问y，可以访问a，但是不能访问s
        class Inner{
            void func(){
                System.out.println(y)
            }
        }

        new Inner().func();
    }
}
```

——————————————————————————————————————————      

### 5、匿名内部类   

匿名内部类，其实就是内部类，
定义一个匿名内部类，必须继承一个类，或实现接口。

> 注意：    
> 能看到的匿名内部类，全都是匿名子类对象。  

格式：new 父类或接口(){ 定义类的内容 }

```java
// 1、先定义一个抽象类
abstract class AbsDemo{
    abstract void show();
}
class Outer
{
    int x = 3;
    public void function (){
        // 2、直接拿AbsDemo接口来new，
        // 后面直接接类的内容，重写其show方法
        AbsDemo d = new AbsDemo(){
            int num = 8;
            void show(){
                System.out.println("show function ");
            }
            void abc(){
                System.out.println("abc function ");
            }
        }

        // 3、d是创建出来的匿名内部类的实例对象，
        // 可以调用匿名内部类里面的方法；
        d.show();
    }
}
// 4、在主函数中调用运行。
class InnerClassDemo4{
    public static void main(String[] args){
        new Outer().function();
    }
}
```
```java
new AbsDemo(){
    int num = 8;
    void show(){
        System.out.println("show function ");
    }
    void abc(){
        System.out.println("abc function ");
    }
}.show(); // Look，也可以在定义了匿名内部类之后直接调用其成员方法。

// 注意，这种写法很少见。
```

> 注意：    
> 为了方便阅读，匿名内部类的方法数不能太多，    
> 如果很多，建议还是用具名，不用匿名。  

——————————————————————————————————————————      

有个问题，如果没有接口怎么办？      
可以用Object作为父类！  

```java
// 直接使用Object作为一个匿名内部类的父类，
// 定义其方法，调用 ，这也是可以的。
new Object(){
    public void func(){

    }
}.func();
```

——————————————————————————————————————————      

## 9.4、异常

啥是异常，就是程序在运行时出现的不正常情况。    

异常分两种。

Throwable
- Exception：不严重的错误，这一类的异常需要进行处理。

- Error： 严重错误，一般不好处理，不对其写针对性的代码，
    - 出现了Error，直接让程序停机就行了。

——————————————————————————————————————————      

### 6、异常处理

异常的处理有两种。  
要么try，要么throw。

1、用try catch finally

```java
try{
    /*
    1、try里面写要运行的，可能会有错误的代码
        当try里面的语句出现错误，会直接停下来，跳转到catch或finally
        而报错的语句后面的语句不会进行执行了。

    */
}catch(Exception e){
    /*
    2、catch，
    对某一个异常进行捕获，进行处理，
    e的类型，不一定是Exception，也可以是Exception的子类，
    比如IOException
    */
    e.message();    // 返回 → 异常的字符串
    e.toString();   // 返回 → 异常名称：异常描述
    e.printStackTrace();    // 在控制台打印异常信息，其内容最详细
}finally{
    /*
    3、finally是所有异常都会执行的异常处理
        可以在这里，去关闭释放一些资源。
    */
}
```
——————————————————————————————————————————      

2、throw Exception      
抛出异常，如果没有被外部catch，则程序停止。

主要在函数上，去声明可能出现的异常，便于提高其安全性，  
使之在调用前就进行处理，不处理则编译失败。

```java
// 直接在函数定义的时候，就throw出可能的异常类型
public static void main(String[] args) throw Exception
{
    System.out.println("hello world");
}
```

——————————————————————————————————————————      

### 7、多异常的处理

1、声明异常的时候，可以更具体一点。
```java

class Demo
{
    // 在函数上，通过throws的关键字声明了该功能有可能会出现问题。
    // 注意，这里用的throws，要加s，不是throw
	int div(int a,int b)throws ArithmeticException,ArrayIndexOutOfBoundsException   
	{
		int[] arr = new int[a];

		System.out.println(arr[4]);

		return a/b;
	}
}
class Exception{
    public static void main(String[] args){
        Demo d = new Demo();

        /*
        在调用Demo类里面的div方法的时候，
        针对多个不同类型的exception，写多个catch进行处理
        throw了几个Exception，就对应几个catch

        如果catch中的异常出现了继承关系，
        父类的异常catch应该放到最下面，

        catch处理的时候，一定要定义具体的处理方式。
        */
        try{
            d.div(5,0);
        }catch(Exception e){
            // 用Exception，也可以，只不过不推荐，
            // 推荐写针对性的异常处理。

        }catch(ArithmeticException e){

        }catch(ArrayIndexOutOfBoundsException e){

        }
    }
}
```

> 注意：    
> 异常应该是针对性的异常，      
> 如果出现意料之外的异常，让程序直接停止，这反而是一个更好的做法。  
>   
> 不要定义多余的catch块。   
> 在实际项目中，一般catch中的异常，可以写进异常日志里面去。 

——————————————————————————————————————————      

8、自定义异常
在项目中会出现特有的问题，可以将特有的问题封装成自定义异常。    

自定义的异常，必须是自定义类继承Exception。

Exception，异常类，     
异常的对象都需要被throw，Exception就具备可抛性。    
只有Exception才可以throw，因为其继承了Throwable     

```java
// 1、定义一个自定义的异常类，继承Exception
class FushuException extends Exception
{
    private int value;
    FushuException(){
        super();
    }
    FushuException(String msg,int value){
        super(msg);
        this.value = value;
    }

    public int getValue(){
        return value;
    }
}

class Demo{
    // 2、Look，在函数上面声明的异常用throws
    int div(int a, int b) throws FushuException
    {
        // 3、当出现传入的参数有负数的时候，手动抛出FushuException
        if(b < 0){
            // 4、手动抛出异常的时候，用的是throw，没有s
            throw new FushuException("出现了除数是负数的情况。");
        }
        return a/b;
    }
}
```
——————————————————————————————————————————      

9、throw和throws    

- throws ：后接异常类，可以多个，用逗号隔开，用在函数定义上；
- throw ：后接异常对象，用在函数的内部。

有一个特殊的异常类，RuntimeException，运行时异常。        
ArithmeticException的父类，就是RuntimeException。       

当抛出了RuntimeException时，不需要throws声明，编译会通过。  

> 为啥？  
> 不需要在函数上用throws声明，是因为这个异常不需要调用者处理。    
> 异常发生的时候，此时的异常使得程序无法继续运算，    
> 
> 所以希望程序直接停止，对代码进行修正。  

```java
// 如果name是一个null，此时会报空指针异常
if(name.equals("lisi")){

}

// 更好的写法，使用下面这个比较，可以避免空指针异常
if("lisi".equals(name)){

}
```

> 注意：    
> 如果自定义异常的时候，该异常发生，程序无法继续，  
> 可以令自定义异常继承RuntimeException，出异常就停机。    
```java
class FushuException extends RuntimeException{
    FushuException(String msg){
        super(msg)
    }
}
class Demo{
    int div(int a, int b) throws FushuException
    {
        if(b < 0){
            // 此时程序停机
            throw new FushuException("出现了除数是负数的情况。");
        }
        return a/b;
    }
}
```

——————————————————————————————————————————      

所以，异常也可以分为，
- 编译时检测到的异常
- 编译时不会被检测的异常，如RuntimeException，以及它的子类

——————————————————————————————————————————      

Exception为啥能被throw？    
其实就是Exception继承了Throwable类。    
```java
class Throwable{

}
class Exception extends Throwable{

}
```