# Vol.10 测试 + 反射 + 注解

## 10.1 单元测试

- 黑盒测试：
    - 不需要写代码，给输入值，看程序是否能够输出期望的值。

- 白盒测试：
    - 需要写代码的。关注程序具体的执行流程。

——————————————————————————————————————————      

## 10.2 Junit 白盒测试

- 1、定义一个测试类
    - Calculator.java → CalculatorTest.java

- 2、定义一个测试方法，测试方法可以独立运行
    - 方法名 add → testAdd
    - 返回值 void
    - 参数 空参数

- 3、给方法加上@test，注意，要先引入junit依赖
```java
import org.junit.Test;

// 红色 测试失败
// 绿色 测试成功

```

- 4、断言
```java
// 参数一，期望值
// 参数二，当前的计算结果
Assert.assertEquals(3,result);
```
——————————————————————————————————————————      

```java
public class CalculatorTest{
    @Before
    public void init(){
        /*
            测试之前执行的内容，加上@before，
            一般用于申请资源
         */
    }

    @After
    public void close(){
        /*
            测试函数执行过后执行的内容，
            一般用来释放资源
         */
    }

    @Test
    public void testAdd(){
        /*
            测试函数
         */
    }
}
```
——————————————————————————————————————————      

## 10.3 反射

框架：是一种半成品软件。可以在框架的基础上进行软件开发，简化编码；

反射：将类的各个组成部分封装为其他对象，这就是反射机制；    
好处：
- 1. 可以在程序运行过程中，操作这些对象 → class对象。
- 2. 解耦，提高程序可扩展性。

——————————————————————————————————————————      

一个.java文件，经过javac编译，变成了.class文件，
如何获取class对象？
```java
// 1、用forName方法，传入一个包名，获取cn.domain里面的Person对象
// → 可以用于加载，用在配置文件中。
Class cls1 = Class.forName("cn.domain.Person");

// 2、已知类，用.class获取 → 可以用于传参
Class cls2 = Person.class;

// 3、已知类的实例，用.getClass方法 → 主要用于对象获取字节码
Person p = new Person();
Class cls3 = p.getClass();
```

> Tips：    
> 同一个字节码文件(*.class)在一次程序运行过程中，**只会被加载一次**，   
> 不论通过哪一种方式，获取的Class对象都是同一个。   
>   
> 例如，上面的cls1，cls2，cls3，三者指向的是同一个class。  

——————————————————————————————————————————      

## 10.4 class对象的功能

class对象的功能，主要是获取class内部的各种成员变量、成员函数、构造方法、类属性等。

- 1、获取成员变量
```java
// 先把class对象拿到手
Class person = Person.class;

// 1.1、获取所有public修饰的成员变量
Field[] fields = person.getFields();
for(Field field : fields){
    System.out.println(field);
}


// 1.2、根据名称获取成员变量
Field a = person.getField("a");


// 1.3、用getDeclaredFields()，可以获取所有的成员变量，无视修饰符
// 不管public还是private，都会获取到
Field[] declaredFields = person.getDeclaredFields();


// 1.4、假设d是private的方法
Field d = person.getDeclaredField("d");
// setAccessible可以设置跳过安全检查
d.setAccessible(true);  // 暴力反射
```
——————————————————————————————————————————      

- 2、获取构造函数

```java
// 先把class对象拿到手
Class person = Person.class;

// 2.1、获取Person的构造函数
Constructor ctr = person.getConstructor(String.class, int.class);


// 2.2、利用获取到的构造函数，创建对象
Object person = ctr.newInstance("王撕葱",30);


// 2.3、构造函数也可以设置暴力反射
ctr.setAccessible(true);
```
——————————————————————————————————————————      

- 3、获取成员方法
```java
// 先把class对象拿到手
Class person = Person.class;

// 3.1、根据名称，获取类中的某一个方法
Method eatMethod = person.getMethod("eat");

// 执行
eatMethod.invoke();
```
——————————————————————————————————————————      

- 4、获取类名
```java
// 先把class对象拿到手
Class person = Person.class;

String clsName = person.getName();
```
——————————————————————————————————————————      

## 10.5 写一个简单的框架类

需求：
- 1、写一个配置，配置里面写有类名，和要执行的方法
- 2、框架类加载这个配置，然后根据里面的配置，运行指定类里面的指定方法。

```java
// Person.java      Person包
package cn.domain;
public class Person{
    private String name;
    private int age;
    public Person(){}
}

// ————————————————————————————————————————————
// Student.java    Student包，
package cn.domain;
public class Student{
    public void sleep(){System.out.println("sleep...");}
}

// ————————————————————————————————————————————
// pro.properties   配置文件
className=cn.domain.Student
methodName=sleep

// ————————————————————————————————————————————
// 框架类
package cn.reflect;
import cn.domain.Student;
import cn.domain.Person;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.util.Properties;

public class ReflectTest{
    public static void main(String[] args)throws Exception{

        // 1、加载配置文件
        ClassLoader clsLoader = ReflectTest.class.getClassLoader();
        InputStream is = clsLoader.getResourceAsStream("pro.properties");
        
        Properties pro = new Properties();
        pro.load(is);

        // 2、获取配置文件中的属性
        String className = pro.getProperty("className");
        String methodName = pro.getProperty("methodName");

        // 3、将配置文件指定好的类，加载到内存
        Class cls = Class.forName(className);

        // 4、创建类的实例
        Object obj = cls.newInstance();

        // 5、获取方法对象
        Method mtd = cls.getMethod(methodName);

        // 6、执行，传入的obj是mtd内部this的指代对象
        mtd.invoke(obj);
    }
}
```
——————————————————————————————————————————      

## 10.6 注解

- 注释：用文字描述程序 → 给程序员看的
- 注解：说明程序 → 给计算机看的

注解（Annotation），也叫元数据。    
一种代码级别的说明。    
它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。    
它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，    
用来对这些元素进行说明，注释。  
——————————————————————————————————————————      

> - JDK1.5之后的新特性
> - 说明程序的
> - 使用注解：@注解名称 

——————————————————————————————————————————      

三种作用
- 1、编写文档：通过代码里标识的注解**生成文档**【生成文档doc文档】

- 2、代码分析：通过代码里标识的注解对代码进行**分析**【使用反射】

- 3、编译检查：通过代码里标识的注解让编译器能够实现基本的**编译检查**【Override】

——————————————————————————————————————————      

jdk预定义的一些注解
- @Override	：增加编译检查，
    - 编译时，检测被该注解标注的方法是否是继承自父类(接口)

- @Deprecated：用来说明以下代码已经过时

- @SuppressWarnings：压制警告，也就是忽略警告。
	- 一般传递参数all  @SuppressWarnings("all")

```java
package cn.annotation;

public class AnnoDemo{
    // Override，编译时，要检查以下方法是否继承自父接口
    @Override
    public String toString(){
        return super.toString();
    }

    // show方法已经过时，你可以用，但是不建议你用
    @Deprecated
    public void show(){}
    public void show2(){}
    public void demo(){
        show(); // 使用过时的方法的时候。会弹警告
    }
}
```

——————————————————————————————————————————      

## 10.7 自定义注解

注解本质上就是一个接口，该接口默认继承Annotation接口。

> 编译与反编译  
> - a.java ---javac---> a.class
> - a.class --javap---> a.java

```java
// MyAnno.java
package cn.annotation;
public @interface MyAnno{
    // 如果外界没有指定属性值，则默认是给value赋值
    int value();

    Person per();
    MyAnno2 anno2();

    String[] strs();
    
    // 可以给注解里面的成员赋初始值，此时使用的时候可以不传值
    String[] s() default "43534";
}

// MyAnno2.java
package cn.annotation;
public @interface MyAnno2{}

// Worker.java      如何使用注解？
@MyAnno(value=12, per=Person.P1, anno2 = @MyAnno2, strs="aaab")
public class Worker{
    public String name = "aaa";
}
```

注解的成员，可以是以下类型
- 基本数据类型
- String
- Enum 枚举
- 注解
- 以上类型的数组

——————————————————————————————————————————      

如果注解里面只传了一个值，默认会赋值给value。

```java
// MyAnno.java
package cn.annotation;
public @interface MyAnno3{
    int value();
}

// Teacher.java
@MyAnno3(12312)
public class Teacher{
    public String name = "bbb";
}
```

——————————————————————————————————————————      

## 10.8 元注解

元注解，用于描述注解的注解
——————————————————————————————————————————      

- @Target 描述注解作用的位置
    - TYPE 类
    - METHOD 方法
    - FIELD 成员变量
```java
import java.lang.annotation.*;

// ElementType是一个枚举类
@Target({
    ElementType.TYPE,
    ElementType.METHOD,
    ElementType.FIELD
})
public @interface MyAnno3{}
```

——————————————————————————————————————————      

- @Retention ：注解被保留的阶段

```java
// 加了这句之后，本方法的所有注解会被保留到class字节码中，被JVM获取到
@Retention(RetentionPolicy.RUNTIME) 
public @interface MyAnno3{}
```
——————————————————————————————————————————      

- @Documented ：注解是否被抽取到api文档中

——————————————————————————————————————————      

- @Inherited ：描述注解是否被子类继承

——————————————————————————————————————————      

## 10.9 在程序中获取注解的属性值

利用注解，实现一个简单的测试框架，

效果：  
给定任意一个类，带@Check注解的方法则进行检查是否出错。   

```java
// 1、定义一个注解
// Check.java 
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Check{}

// 2、需要测试的代码
// Calculator.java
public class Calculator{
    @Check
    public void add(){

    }

    @Check
    public void sub(){

    }
}

// 3、测试
public class TestCheck{
    public static void main(String[] args)throws IOException{
        // 1、定义一个实例
        Calculator c = new Calculator();
        // 2、获取这个实例的class对象
        Class cls = c.getClass();

        // 3、获取所有的方法
        Method[] methods = cls.getMethods();

        // 4、设置number，用来记录出错的条数
        int number = 0;

        // 5、设置一个文件，用来做错误记录
        BufferedWriter bw = new BufferedWriter(new FileWriter("bug.txt"));

        for(Method method : methods){
            // 6、如果这个方法，带有Check注解，则进行检查
            if(method.isAnnotationPresent(Check.class)){
                try{
                    // 7、尝试执行这个方法
                    method.invoke(c);
                }catch(Exception e){
                    // 8、如果出错，则记录错误信息到文本中
                    number++;

                    bw.write(method.getName()+ " 方法出异常了");
                    bw.newLine();
                    bw.write("异常的名称:" + e.getCause().getClass().getSimpleName());
                    bw.newLine();
                    bw.write("异常的原因:"+e.getCause().getMessage());
                    bw.newLine();
                    bw.write("--------------------------");
                    bw.newLine();
                }
            }
        }

        // 9、遍历完成后，记录结果
        bw.write("本次测试一共出现 "+number+" 次异常");

        // 10、回写到文件中，关闭写入流
        bw.flush();
        bw.close();
    }
}
```

