# Vol.28 多表查询+事务+DCL

## 28.1、查询

select + from + where

如何同时查两个表？
```sql
select * from emp,dept;
```

这样查出来的结果，其实是emp和dept两个表的**笛卡尔积**。

——————————————————————————————————————————      

## 28.2、笛卡尔积

两个集合A，B，取两个集合的所有组合。

但是，在多表中，笛卡尔积的结果并不是我们想要的， 
里面有很多是无用的数据。

所以多表查询时，需要加筛选条件。

——————————————————————————————————————————      

## 28.3、多表查询

- 内连接查询
    - 隐式内连接
    - 显式内连接

——————————————————————————————————————————      
隐式内连接：

```sql
/* 1、在 where 后面加上一些条件，把无效的信息筛除 */
select 
    /* 用 表名.字段名 的方式来取字段 */
    emp.name, emp.gender, dept.name     
from 
    emp, dept
where
    emp.`dept_id` = dept.`id`;

/* 2、并且，可以给emp dept表加一个别名 */
select 
    t1.name, t1.gender, t2.name    
from 
    emp t1, dept t2     /* 重命名emp为t1，dept为t2 */
where
    t1.`dept_id` = t2.`id`
```
——————————————————————————————————————————      
显式内连接：

```sql
select * from 
    emp 
INNER JOIN  /* 用 inner join 来连接两个表 */
    dept
on          /* 用 on 来写筛选条件 */
    emp.`dept_id` = dept.`id`;
```
——————————————————————————————————————————      

- 外连接查询
    - 左外连接
    - 右外连接

```sql
/*
    假如有两个集合 A，B，两个的交集是 A & B
    | A | A & B | B |

    左外连接：A + A & B
    右外连接：B + A & B
*/

/* 1、左外连接 */
select * from 
    emp t1
left join 
    dept t2
on 
    t1.`dept_id` = t2.`id`;

/* 2、右外连接 */
select * from 
    dept t2
right join 
    emp t1
on 
    t1.`dept_id` = t2.`id`;
```
——————————————————————————————————————————      

- 子查询：查询中嵌套查询，嵌套的查询就是子查询
    - 子查询结果单行单列
    - 子查询结果多行单列
    - 子查询结果多行多列

```sql
/* 1、原本的查询，查询表中最高salary的数据 */
select MAX(salary) from emp;
select * from emp where emp.`salary` = 9000;

/* 2、使用子查询之后 */
select * from emp where emp.`salary` = (select MAX(salary) from emp);
```
——————————————————————————————————————————      

```sql
/* 1、单行单列，可以用运算符：>，>=，<，<=，= */
select * from emp where emp.salary < (select AVG(salary) from emp);

/* ——————————————————————————————————————————————————————————————— */

/* 2、多行单列，用in */
/* 原本的操作，分别查两个表 */
select id from dept where name='xxx' or name='yyy';
select * from emp where dept_id=3 or dept_id=2;
/* 子查询的操作，一句搞定 */
select * from 
    emp 
where
    dept_id
in
    (select id from dept where name='xxx' or name='yyy');

/* ——————————————————————————————————————————————————————————————— */

/* 3、多行多列，可以把子查询当做一个虚拟表集合 */
select * from 
    /* 把子查询的结果，和表的地位等同起来 */
    dept t1,
    (select * from emp where emp.`join_date`>'2011-1-11') t2
where
    t1.id=t2.dept_id;
```
——————————————————————————————————————————      

## 28.4、练习

### 28.4.1、建表

```sql
-- 1、部门表
CREATE TABLE dept (
    id INT PRIMARY KEY PRIMARY KEY, -- 部门id
    dname VARCHAR(50), -- 部门名称
    loc VARCHAR(50) -- 部门所在地
);

-- 1.1、添加4个部门
INSERT INTO 
    dept(id,dname,loc) 
VALUES 
    (10,'教研部','北京'),
    (20,'学工部','上海'),
    (30,'销售部','广州'),
    (40,'财务部','深圳');

-- 2、职务表，职务名称，职务描述
CREATE TABLE job (
    id INT PRIMARY KEY,
    jname VARCHAR(20),
    description VARCHAR(50)
);

-- 2.1、添加4个职务
INSERT INTO 
    job (id, jname, description) 
VALUES
    (1, '董事长', '管理整个公司，接单'),
    (2, '经理', '管理部门员工'),
    (3, '销售员', '向客人推销产品'),
    (4, '文员', '使用办公软件');

-- 3、员工表
CREATE TABLE emp (
    id INT PRIMARY KEY, -- 员工id
    ename VARCHAR(50), -- 员工姓名

    job_id INT, -- 职务id
    CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),
    
    mgr INT , -- 上级领导
    joindate DATE, -- 入职日期
    salary DECIMAL(7,2), -- 工资
    bonus DECIMAL(7,2), -- 奖金

    dept_id INT, -- 所在部门编号
    CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)
);

-- 3.1、添加员工
INSERT INTO 
    emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) 
VALUES 
    (1001,'孙悟空',4,1004,'2000-12-17','8000.00',NULL,20),
    (1002,'卢俊义',3,1006,'2001-02-20','16000.00','3000.00',30),
    (1003,'林冲',3,1006,'2001-02-22','12500.00','5000.00',30),
    (1004,'唐僧',2,1009,'2001-04-02','29750.00',NULL,20),
    (1005,'李逵',4,1006,'2001-09-28','12500.00','14000.00',30),
    (1006,'宋江',2,1009,'2001-05-01','28500.00',NULL,30),
    (1007,'刘备',2,1009,'2001-09-01','24500.00',NULL,10),
    (1008,'猪八戒',4,1004,'2007-04-19','30000.00',NULL,20),
    (1009,'罗贯中',1,NULL,'2001-11-17','50000.00',NULL,10),
    (1010,'吴用',3,1006,'2001-09-08','15000.00','0.00',30),
    (1011,'沙僧',4,1004,'2007-05-23','11000.00',NULL,20),
    (1012,'李逵',4,1006,'2001-12-03','9500.00',NULL,30),
    (1013,'小白龙',4,1004,'2001-12-03','30000.00',NULL,20),
    (1014,'关羽',4,1007,'2002-01-23','13000.00',NULL,10);

-- 工资等级表
CREATE TABLE salarygrade (
    grade INT PRIMARY KEY,   -- 级别
    losalary INT,  -- 最低工资
    hisalary INT -- 最高工资
);

-- 添加5个工资等级
INSERT INTO 
    salarygrade(grade,losalary,hisalary) 
VALUES 
    (1,7000,12000),
    (2,12010,14000),
    (3,14010,20000),
    (4,20010,30000),
    (5,30010,99990);
```

所以我们有了四张表
- dept : 部门表
- emp : 员工表
- job : 职位表
- salarygrade : 工资等级表

### 28.4.2 查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述

```sql
SELECT 
	t1.id, 
    t1.ename, 
    t1.salary, 
    t1.bonus,
    t2.`description`
FROM 
	emp t1,
	job t2
WHERE 
	t1.`job_id`=t2.`id`;
```

### 28.4.3 查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置

```sql
SELECT
	t1.id, t1.ename, t1.`salary`, 
	t2.`jname`,t2.`description`,
	t3.`dname`,t3.`loc`
FROM 
	emp t1,
	job t2,
	dept t3
WHERE 
	t1.`dept_id`=t3.`id` 
AND
	t1.`job_id`=t2.`id`
```

### 28.4.4 查询员工姓名，工资，工资等级

```sql
SELECT 
	t1.`ename`,
    t1.`salary`,
	t2.`grade`
FROM 
	emp t1,
	salarygrade t2
WHERE
	t1.`salary`>=t2.`losalary`
	AND
	t1.`salary`<t2.`hisalary`;

/* 也可以用between */
SELECT 
	t1.ename ,
	t1.`salary`,
	t2.*
FROM 
    emp t1, 
    salarygrade t2
WHERE 
    t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;
```

## 28.4.5 查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级

```sql
SELECT 
	t1.`ename`,
	t1.`salary`,
	t2.`jname`,
	t2.`description`,
	t3.`dname`,
	t3.`loc`,
	t4.`grade`
FROM 
	emp t1,
	job t2,
	dept t3,
	salarygrade t4
WHERE
	t2.`id`=t1.`job_id`
	AND
	t3.`id`=t1.`dept_id`
	AND
	t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;
```

## 28.4.6 查询出部门编号、部门名称、部门位置、部门人数

```sql
/* 易错，注意要用group by分组查询+子查询 */
SELECT
	t1.id,
	t1.`dname`,
	t1.`loc`,
	t2.total
FROM 
	dept t1,
	(SELECT dept_id,COUNT(id) total FROM emp GROUP BY dept_id) t2
WHERE
	t2.`dept_id`=t1.id;
```

## 28.4.7 查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询

这题有点弯需要绕。

```sql
/*  第一种，当然是用内连接
    但是有个问题，没有领导的员工没被查出来
 */
SELECT 
	t1.`ename`,
	t2.ename mgr_name
FROM 
	emp t1,
	emp t2
WHERE
	t1.`mgr`=t2.`id`;

/*  第二种方法，显然这是emp 和emp关联
    我们可以用左外连接，以emp作为基础，增加emp和emp之间关联的部分。
 */
SELECT 
	t1.`ename`,
	t1.`id`,
	t2.`mgr`,
	t2.`ename` mgr_name
FROM 
	emp t1
LEFT JOIN 
	emp t2
ON 
	t1.`mgr`=t2.`id`;
```

