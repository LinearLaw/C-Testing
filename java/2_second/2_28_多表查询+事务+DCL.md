# Vol.28 多表查询+事务+DCL

## 28.1、查询

select + from + where

如何同时查两个表？
```sql
select * from emp,dept;
```

这样查出来的结果，其实是emp和dept两个表的**笛卡尔积**。

——————————————————————————————————————————      

## 28.2、笛卡尔积

两个集合A，B，取两个集合的所有组合。

但是，在多表中，笛卡尔积的结果并不是我们想要的， 
里面有很多是无用的数据。

所以多表查询时，需要加筛选条件。

——————————————————————————————————————————      

## 28.3、多表查询

- 内连接查询
    - 隐式内连接
    - 显式内连接

——————————————————————————————————————————      
隐式内连接：

```sql
/* 1、在 where 后面加上一些条件，把无效的信息筛除 */
select 
    /* 用 表名.字段名 的方式来取字段 */
    emp.name, emp.gender, dept.name     
from 
    emp, dept
where
    emp.`dept_id` = dept.`id`;

/* 2、并且，可以给emp dept表加一个别名 */
select 
    t1.name, t1.gender, t2.name    
from 
    emp t1, dept t2     /* 重命名emp为t1，dept为t2 */
where
    t1.`dept_id` = t2.`id`
```
——————————————————————————————————————————      
显式内连接：

```sql
select * from 
    emp 
INNER JOIN  /* 用 inner join 来连接两个表 */
    dept
on          /* 用 on 来写筛选条件 */
    emp.`dept_id` = dept.`id`;
```
——————————————————————————————————————————      

- 外连接查询
    - 左外连接
    - 右外连接

```sql
/*
    假如有两个集合 A，B，两个的交集是 A & B
    | A | A & B | B |

    左外连接：A + A & B
    右外连接：B + A & B
*/

/* 1、左外连接 */
select * from 
    emp t1
left join 
    dept t2
on 
    t1.`dept_id` = t2.`id`;

/* 2、右外连接 */
select * from 
    dept t2
right join 
    emp t1
on 
    t1.`dept_id` = t2.`id`;
```
——————————————————————————————————————————      

- 子查询：查询中嵌套查询，嵌套的查询就是子查询
    - 子查询结果单行单列
    - 子查询结果多行单列
    - 子查询结果多行多列

```sql
/* 1、原本的查询，查询表中最高salary的数据 */
select MAX(salary) from emp;
select * from emp where emp.`salary` = 9000;

/* 2、使用子查询之后 */
select * from emp where emp.`salary` = (select MAX(salary) from emp);
```
——————————————————————————————————————————      

```sql
/* 1、单行单列，可以用运算符：>，>=，<，<=，= */
select * from emp where emp.salary < (select AVG(salary) from emp);

/* ——————————————————————————————————————————————————————————————— */

/* 2、多行单列，用in */
/* 原本的操作，分别查两个表 */
select id from dept where name='xxx' or name='yyy';
select * from emp where dept_id=3 or dept_id=2;
/* 子查询的操作，一句搞定 */
select * from 
    emp 
where
    dept_id
in
    (select id from dept where name='xxx' or name='yyy');

/* ——————————————————————————————————————————————————————————————— */

/* 3、多行多列，可以把子查询当做一个虚拟表集合 */
select * from 
    /* 把子查询的结果，和表的地位等同起来 */
    dept t1,
    (select * from emp where emp.`join_date`>'2011-1-11') t2
where
    t1.id=t2.dept_id;
```
——————————————————————————————————————————      

## 28.4、练习

### 28.4.1、建表

```sql
-- 1、部门表
CREATE TABLE dept (
    id INT PRIMARY KEY PRIMARY KEY, -- 部门id
    dname VARCHAR(50), -- 部门名称
    loc VARCHAR(50) -- 部门所在地
);

-- 1.1、添加4个部门
INSERT INTO 
    dept(id,dname,loc) 
VALUES 
    (10,'教研部','北京'),
    (20,'学工部','上海'),
    (30,'销售部','广州'),
    (40,'财务部','深圳');

-- 2、职务表，职务名称，职务描述
CREATE TABLE job (
    id INT PRIMARY KEY,
    jname VARCHAR(20),
    description VARCHAR(50)
);

-- 2.1、添加4个职务
INSERT INTO 
    job (id, jname, description) 
VALUES
    (1, '董事长', '管理整个公司，接单'),
    (2, '经理', '管理部门员工'),
    (3, '销售员', '向客人推销产品'),
    (4, '文员', '使用办公软件');

-- 3、员工表
CREATE TABLE emp (
    id INT PRIMARY KEY, -- 员工id
    ename VARCHAR(50), -- 员工姓名

    job_id INT, -- 职务id
    CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),
    
    mgr INT , -- 上级领导
    joindate DATE, -- 入职日期
    salary DECIMAL(7,2), -- 工资
    bonus DECIMAL(7,2), -- 奖金

    dept_id INT, -- 所在部门编号
    CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)
);

-- 3.1、添加员工
INSERT INTO 
    emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) 
VALUES 
    (1001,'孙悟空',4,1004,'2000-12-17','8000.00',NULL,20),
    (1002,'卢俊义',3,1006,'2001-02-20','16000.00','3000.00',30),
    (1003,'林冲',3,1006,'2001-02-22','12500.00','5000.00',30),
    (1004,'唐僧',2,1009,'2001-04-02','29750.00',NULL,20),
    (1005,'李逵',4,1006,'2001-09-28','12500.00','14000.00',30),
    (1006,'宋江',2,1009,'2001-05-01','28500.00',NULL,30),
    (1007,'刘备',2,1009,'2001-09-01','24500.00',NULL,10),
    (1008,'猪八戒',4,1004,'2007-04-19','30000.00',NULL,20),
    (1009,'罗贯中',1,NULL,'2001-11-17','50000.00',NULL,10),
    (1010,'吴用',3,1006,'2001-09-08','15000.00','0.00',30),
    (1011,'沙僧',4,1004,'2007-05-23','11000.00',NULL,20),
    (1012,'李逵',4,1006,'2001-12-03','9500.00',NULL,30),
    (1013,'小白龙',4,1004,'2001-12-03','30000.00',NULL,20),
    (1014,'关羽',4,1007,'2002-01-23','13000.00',NULL,10);

-- 工资等级表
CREATE TABLE salarygrade (
    grade INT PRIMARY KEY,   -- 级别
    losalary INT,  -- 最低工资
    hisalary INT -- 最高工资
);

-- 添加5个工资等级
INSERT INTO 
    salarygrade(grade,losalary,hisalary) 
VALUES 
    (1,7000,12000),
    (2,12010,14000),
    (3,14010,20000),
    (4,20010,30000),
    (5,30010,99990);
```

——————————————————————————————————————————      

所以我们有了四张表
- dept : 部门表
- emp : 员工表
- job : 职位表
- salarygrade : 工资等级表

——————————————————————————————————————————      

### 28.4.2 查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述

```sql
SELECT 
	t1.id, 
    t1.ename, 
    t1.salary, 
    t1.bonus,
    t2.`description`
FROM 
	emp t1,
	job t2
WHERE 
	t1.`job_id`=t2.`id`;
```
——————————————————————————————————————————      

### 28.4.3 查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置

```sql
SELECT
	t1.id, t1.ename, t1.`salary`, 
	t2.`jname`,t2.`description`,
	t3.`dname`,t3.`loc`
FROM 
	emp t1,
	job t2,
	dept t3
WHERE 
	t1.`dept_id`=t3.`id` 
AND
	t1.`job_id`=t2.`id`
```
——————————————————————————————————————————      

### 28.4.4 查询员工姓名，工资，工资等级

```sql
SELECT 
	t1.`ename`,
    t1.`salary`,
	t2.`grade`
FROM 
	emp t1,
	salarygrade t2
WHERE
	t1.`salary`>=t2.`losalary`
	AND
	t1.`salary`<t2.`hisalary`;

/* 也可以用between */
SELECT 
	t1.ename ,
	t1.`salary`,
	t2.*
FROM 
    emp t1, 
    salarygrade t2
WHERE 
    t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;
```
——————————————————————————————————————————      

## 28.4.5 查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级

```sql
SELECT 
	t1.`ename`,
	t1.`salary`,
	t2.`jname`,
	t2.`description`,
	t3.`dname`,
	t3.`loc`,
	t4.`grade`
FROM 
	emp t1,
	job t2,
	dept t3,
	salarygrade t4
WHERE
	t2.`id`=t1.`job_id`
	AND
	t3.`id`=t1.`dept_id`
	AND
	t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;
```
——————————————————————————————————————————      

## 28.4.6 查询出部门编号、部门名称、部门位置、部门人数

```sql
/* 易错，注意要用group by分组查询+子查询 */
SELECT
	t1.id,
	t1.`dname`,
	t1.`loc`,
	t2.total
FROM 
	dept t1,
	(SELECT dept_id,COUNT(id) total FROM emp GROUP BY dept_id) t2
WHERE
	t2.`dept_id`=t1.id;
```
——————————————————————————————————————————      

## 28.4.7 查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询

这题有点弯需要绕。

```sql
/*  第一种，当然是用内连接
    但是有个问题，没有领导的员工没被查出来
 */
SELECT 
	t1.`ename`,
	t2.ename mgr_name
FROM 
	emp t1,
	emp t2
WHERE
	t1.`mgr`=t2.`id`;

/*  第二种方法，显然这是emp 和emp关联
    我们可以用左外连接，以emp作为基础，增加emp和emp之间关联的部分。
 */
SELECT 
	t1.`ename`,
	t1.`id`,
	t2.`mgr`,
	t2.`ename` mgr_name
FROM 
	emp t1
LEFT JOIN 
	emp t2
ON 
	t1.`mgr`=t2.`id`;
```
——————————————————————————————————————————      

## 28.5 事务

如果一个包含多个步骤的业务操作，被事务管理，    
那么这些操作要么同时成功，要么同时失败。    

```sql
/* 1. 开启事务：  */
start transaction;

/* 然后做一些sql操作*/

/* 2. 回滚：此时做过的sql操作会回退到开启事务之前 */
rollback;
/* 3. 提交： 此时做过的sql操作会被保存*/
commit;
```
——————————————————————————————————————————      

主要是，    
执行多条sql语句，可能会出问题，     
因此需要在出错时，回退到没有出问题之前。    

开启事务之后，要手动commit，做的操作才会保存，  
否则做的所有事情都是临时的更改，关闭连接就丢失。    

——————————————————————————————————————————      

事务的提交有两种方式
- 自动提交：
	* mysql就是自动提交的
	* 一条DML(增删改)语句会自动提交一次事务。
- 手动提交：
	* Oracle 数据库默认是手动提交事务
	* 需要先开启事务，再提交

——————————————————————————————————————————      

```sql
/* 查看事务的默认提交方式：*/
SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交

/* 修改默认提交方式： */
set @@autocommit = 0;
```
——————————————————————————————————————————      

事务的四大特征（**面试常考**）

- 1、原子性：事务是不可分割的最小操作单位，要么同时成功，要么同时失败。

- 2、持久性：当事务提交或回滚后，数据库会持久化的保存数据。

- 3、隔离性：多个事务之间。相互独立。

- 4、一致性：事务操作前后，数据总量不变

——————————————————————————————————————————      

事务可能出现什么问题？  

多个事务之间是相互隔离的，但是，操作的数据，可能是同一批，  
多个事务操作同一批数据，就会有同步问题。    

- 1、 脏读：一个事务，读取到另一个事务中没有提交的数据。

- 2、 不可重复读（虚读）：在同一个事务中，两次读取到的数据不一样。

- 3、 幻读：    
    事务A改了数据，事务B改了数据，  
    然后B提交了，A的改动消失了。    

    > 一个事务操作(DML)数据表中所有记录，而另一个事务此时添加了一条数据，     
    >  则第一个事务查询不到自己的修改。     
    > mysql要实现幻读有点困难，因为其隔离级别是 repeatable read。

——————————————————————————————————————————      

事务的隔离级别（了解即可）
- 1、 read uncommitted：读未提交
	* 产生的问题：脏读、不可重复读、幻读

- 2、 read committed：读已提交 （Oracle）
	* 产生的问题：不可重复读、幻读

- 3、 repeatable read：可重复读 （MySQL默认）
	* 产生的问题：幻读

- 4、 serializable：串行化
	* 可以解决所有的问题，相当于加了锁

> 注意：隔离级别从小到大安全性越来越高，但是效率越来越低；

```sql
/* 数据库查询隔离级别： */
select @@tx_isolation;

/* 数据库设置隔离级别： */
set global transaction isolation level read uncommitted;
```
——————————————————————————————————————————      

## 28.6 DCL

- SQL分类：
	- 1、 DDL：操作数据库和表
	- 2、 DML：增删改表中数据
	- 3、 DQL：查询表中数据
	- 4、 DCL：管理用户，授权

DBA：数据库管理员

DCL：用来管理用户、分配权限操作权限的命令

```sql
/* 1、添加用户
    root是账户名，localhost是主机名，如果不限制主机名，可以用 %
 */
create user 'root'@'localhost' identified by 'password';

/* 2、删除用户 */
drop user 'root'@'localhost';

/* 3、查找某一个用户 */
use mysql;  -- 切换到mysql的mysql数据库
select * from user;     

/* 4、改密码 */
/* 以下两种都行 */
update user set password=password('abc') where user='root';

set password for 'root'@'localhost'=password('123');
```
——————————————————————————————————————————      

> 5、如果root用户，忘记了密码咋办 
> - 1、 cmd -- > net stop mysql 停止mysql服务
>     - 需要管理员运行该cmd
> 
> - 2、 使用无验证方式启动mysql服务： 
>     - mysqld --skip-grant-tables
> 
> - 3、 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功
> 
> - 4、 use mysql;
> 
> - 5、 update user set password = password('你的新密码') where user = 'root';
> 
> - 6、 关闭两个窗口
> 
> - 7、 打开任务管理器，手动结束mysqld.exe 的进程
> 
> - 8、 启动mysql服务
> 
> - 9、 使用新密码登录。

——————————————————————————————————————————      

权限管理

```sql
/* 1、查看某一个用户的权限，% 代表了所有主机 */
show grants for 'lisi'@'%';


/* 2、分配权限
    all 是权限列表，all表示所有权限
    *.* 数据库名.表名，代表所有数据库和所有表
 */
grant all on *.* to 'lisi'@'%';

/* 3、撤销权限
    update 权限列表，update表示是一个更新的权限
    db3.'account' 数据库名.表名
 */
revoke update on db3.'account' from 'lisi'@'%';
```
——————————————————————————————————————————      
