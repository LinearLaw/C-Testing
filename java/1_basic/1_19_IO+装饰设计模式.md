# Vol.19 

## 19.1、 字符流缓冲区

缓冲区主要结合流进行使用。  
在构造一个缓冲区的时候，需要传入一个流对象。    

- BufferedWriter
- BufferedReader

> Tips：换行符有两种，\r 和 \r\n    

```java
FileWriter fw = new FileWriter("buf.txt");
BufferedWriter bufw = new BufferedWriter(fw);

// 写入字符串
bufw.write("xxxx");

// 往文件中写入一个换行
bufw.newLine();

// 刷新，将改动更新到硬盘文件
bufw.flush();

// 关闭流，关闭了bufw，fw也会被关闭
bufw.close();
```
——————————————————————————————————————————      

```java
FileReader fr = new FileReader("buf.txt");
BufferedReader bufr = new BufferedReader(fr);

// 读一行的字符，注意，readLine读出的字符没有换行符
bufr.readLine();
bufr.close();
```
——————————————————————————————————————————      
> Tips：    
> 缓冲引入后，写法其实没有很大区别，    
> 但是缓冲区提高了读写的性能。  
——————————————————————————————————————————      

```java
// CopyTextByBuf.java
/** 
 * 读取某一个java文件，将其复制到另一个文件中
 * 使用缓冲区
 */
import java.io.*;

class CopyTextByBuf
{
    public static void main(String[] args){
        BufferedReader bufr = null;
        BufferedWriter bufw = null;

        try{
            bufr = new BufferedReader(new FileReader("xxxxxx.java"));
            bufw = new BufferedWriter(new FileWriter("x-copy.java"));

            String line = null;
            while((line=bufr.readLine())!=null){
                bufw.write(line);
                bufw.newLine();
                bufw.flush();
            }
        }catch(IOException e){
            throw new RuntimeException("读写失败");
        }finally{
            // 尝试关闭读取流
            try{
                if(bufr!=null){bufr.close();}
            }catch(IOException e){
                throw new RuntimeException("关闭读取流失败");
            }

            // 尝试关闭写入流
            try{
                if(bufw!=null){bufw.close();}
            }catch(IOException e){
                throw new RuntimeException("关闭写入流失败");
            }
        }
    }
}
```
——————————————————————————————————————————      

- fw.readLine() ：读取某一行，原理其实就是read()，读取到换行符就结束。

```java
import java.io.*;

/**
 * 用read()方法实现readLine
 * 其实就是每次读出一个字符之后，判断是否是换行符，到了换行符则返回结果
 */
class MyBufferedReader extends Reader{
    private Reader r;
    MyBufferedReader(Reader r){
        this.r = r;
    }

    public String myReadLine()throws IOException
    {
        StringBuilder sb = new StringBuilder();
        int ch = 0;

        // read方法一个一个字符读取文件中的字符
        while((ch=r.read())!=-1){
            // 遇到空格则继续下一个字符
            if(ch == '\r'){
                continue;
            }
            // 遇到换行，则直接返回当前的字符串
            if(ch == '\n'){
                return sb.toString();
            }else{
                sb.append((char)ch);
            }
        }

        if(sb.length()!=0){
            return sb.toString();
        }
        return null;
    }
    public int read(char[] cbuf,int off, int len)throws IOException{
        return r.read(cbuf,off,len);
    }
    public void close()throws IOException{
        r.close();
    }
}
class MyBufferedReaderDemo{
    public static void main(String[] args)throws IOException{
        FileReader fr = new FileReader("xxx,txt");
        MyBuffered myBuf = new MyBufferedReader(fr);

        String line = null;
        while((line=myBuf.myReadLine())!=null){
            System.out.println(line);
        }
        myBuf.close();
    }
}
```
——————————————————————————————————————————      

## 19.2、装饰设计模式

装饰设计模式，其实就是对某一个方法进行增强。    
定义一个类，将已有的对象传入，基于已有的功能，并提供加强的功能。    
这个类就是装饰类。    

例1、
```java
// 一个普普通通的对象
class Person{
    public void eat(){
        System.out.println("吃饭");
    }
}

// 一个加强版的对象
class SuperPerson{
    private Person p;
    // 构造时，传入一个对象
    SuperPerson(Person p){
        this.p = p;
    }
    // 对原有的普通对象进行加强
    public void superEat(){
        System.out.println("开胃酒");
		p.eat();
		System.out.println("甜点");
		System.out.println("来一根");
    }
}
```
例2、
```java
/**
比如有一个MyReader的类
- MyReader
    - MyTextReader
        - MyBufferedTextReader

    - MyMediaReader
        - MyBufferedMediaReader
 */
// 最初，我们可以这样构造
class MyBufferReader{
    MyBufferReader(MyTextReader text){}
    MyBufferReader(MyMediaReader media){}
}

/* 
    上面的构造方法，扩展性极差
    如果后面又有一个MyDataReader，又要重写一个构造函数
    所以就可以用装饰器模式，来简化构造
*/
class MyBufferReader extends MyReader{
    private MyReader r;
    // 这里使用了多态，只要是MyReader或MyReader的子类都可以
    MyBufferedReader(MyReader r){}
}
```

> Tips：    
> 装饰模式，避免了继承体系的臃肿。  

——————————————————————————————————————————      

## 19.3、LineNumberReader
```java
FileReader fr = new FileReader("xx.java");
LineNumberReader lnr = new LineNumberReader(fr);

// 获取当前行号
int lineCount = lnr.getLineNumber();    

// 将当前的光标定位到某一行
lnr.setLineNumber(100);
```
原理：内置计数器。  
利用装饰设计模式，对原有的Reader进行增强，增加计行数的功能。    

——————————————————————————————————————————      

## 19.4、操作字节流

- InputStream

- OutputStream

```java
FileOutputStream fos = new FileOutputStream("fos.txt");

// 向fos里面写入的数据，是二进制的数据
fos.write("aaccddd".getBytes());

// 操作完成后，无需flush
fos.close();
```
——————————————————————————————————————————      

```java
FileInputStream fis = new FileInputStream("fos.txt");
int ch = 0;

// fis.read() 读出的是1个字节的数据
while((ch=fis.read())!=-1){
    System.out.println((char)ch);
}
```
——————————————————————————————————————————      

```java
FileInputStream fis = new FileInputStream("fos.txt");

// fis.available()返回一个可用的byte的长度
//      需要谨慎使用，因为返回的是fos.txt的全部长度
//      如果fos.txt很大，内存就爆了
byte[] buf = new byte[fis.available()];

// 读取一个buf长度的数据，存入buf
fis.read(buf);
```

——————————————————————————————————————————      

例、用字节流拷贝一个图片
```java
import java.io.*;

class CopyPic{
    public static void main(String[] args){
        FileOutputStream fos = null;
        FileInputStream fis = null;
        try{
            fos = new FileOutputStream("a.bmp");
            fis = new FileInputStream("a-copy.bmp");

            byte[] buf = new byte[1024];
            int len = 0;

            // 读取fis的内容，写入到fos
            while((len=fis.read(buf))!=-1){
                fos.write(buf,0,len);
            }
        }catch(IOException e){
            throw new RuntimeException("复制文件失败")
        }finally{
            // 尝试关闭读取流
            try{
                if(fis!=null){fis.close();}
            }catch(IOException e){
                throw new RuntimeException("读取关闭失败");
            }

            // 尝试关闭写入流
            try{
                if(fos!=null){fos.close();}
            }catch(IOException e){
                throw new RuntimeException("写入关闭失败");
            }
        }
    }
}
```

——————————————————————————————————————————      

## 19.5、字节流的缓冲区

- BufferOutputStream

- BufferInputStream

操作和字符流的缓冲区基本一致。  
在创建缓冲区的时候，传入一个FileInputStream或者FileOutputStream对象。   

然后后面就操作这个缓冲区就行。  

——————————————————————————————————————————      

自己写一个缓冲区？

```java
class MyBufferedInputStream{
    private InputStream in;
    private byte[] buf = new byte[1024*4];
    private int pos = 0,count=0;

    MyBufferedInputStream(InputStream in){
        this.in = in;
    }

    public int myRead()throws IOException{
        if(count == 0){
            count = in.read(buf);
            if(count < 0){return -1;}

            pos = 0;
            byte b = buf[pos];
            count --;
            pos ++;

            // byte是8位的，b也是8位的，
            // 但是要补0变成24位，所以和255做与运算
            return b & 255;
        }
    }
    public void myClose()throws IOException{
        in.close();
    }
}
```

——————————————————————————————————————————      

## 19.6、读取键盘的输入

```java
/**
    System.out 对应的是标准输出设备，例如控制台
    System.in  对应的是标注输入设备，例如键盘

    例、输入一串字符，输出这串字符的大写字符
 */
import java.io.*;

class ReadKeyBoard{
    public static void main(String[] args)throws IOException{
        InputStream in = System.in;
        StringBuilder sb = new StringBuilder();

        while(true){
            // 等待键盘录入，录入之后就赋值给ch，在这里，线程会阻塞，等待输入
            int ch = in.read();

            // 空格则等待下一次录入
            if(ch == '\r'){continue;}

            // 换行符
            if(ch == '\n'){
                String s = sb.toString();
                // 输入了over，则停止输入
                if("over",equals(s)){
                    break;
                }

                // 输出当前输入内容的大写字符
                System.out.println(s.toUpperCase());

                // 输出完了之后，将sb空出来
                sb.delete(0,sb.length());
            }else{
                sb.append((char)ch);
            }
        }
    }
}
```

——————————————————————————————————————————      

## 19.7、读取转换流

- 字节 → 字符 : InputStreamReader

- 字符 → 字节 : OutputStreamWriter

```java
/*
 
 */
class TransStream{
    public static void main(String[] args)throws IOException{

        // System.setIn和setOut是重新更改输入流和输出流
        // 设置输入目标，传入的是文件输入流
        System.setIn(new FileInputStream("PersonDemo.java"));

        // 设置输出目标，输出到一个文件中
        System.setOut(new PrintStream("zzz.java"));

        // 创建一个读取缓冲器
        BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));

        // 创建一个写入缓冲器
        BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));

        String line = null;
        // 开始读，每次读一行，写入到刚刚的输入目标中。
        while((line=bufr.readLine())!=null){
            // 以 over 作为结尾
            if("over".equals(line)){break;}

            bufw.write(line.toUpperCase());
            bufw.newLine();
            bufw.flush();
        }

        bufw.close();
    }
}
```

——————————————————————————————————————————      

## 19.8、异常的错误信息记录

相关工具：log4j

主要是用PrintStream实现。

> 思路：    
> 当捕获到了错误的时候，创建一个PrintStream对象，将错误信息写进去   

——————————————————————————————————————————      

## 19.9、系统信息System

```java
Property prop = System.getProperties();

// 将系统信息写入到某一个文件中。
prop.list(new PrintStream("sysinfo.txt"));
```

——————————————————————————————————————————      
