# Vol.12 线程间通信

## 12.1、多个线程操作同一资源

输入输出都要加synchronized
- Input
- Output 

等待唤醒机制
- r.wait()  → 移入线程池
- r.notify()    → 唤醒线程
- r.notifyAll() → 唤醒所有

这些操作都使用在同步中，因为要对持有锁的线程进行操作。

为什么他们都在Object中？    
因为他们在操作同步中的线程时，必须标识他们所操作线程持有的锁。  

同一个锁中wait，可以被同一个锁的notify唤醒。    

InputOutputDemo.java

——————————————————————————————————————————      

## 12.2、生产者消费者

ProducerConsumerDemo.java

——————————————————————————————————————————      

## 12.3、JDK 1.5

Lock：替代了Synchronized
- lock()
- unlock()
- newCondition()

Condition ：替代了Object wait notify notifyAll
- await()
- signal()
- signalAll()

——————————————————————————————————————————      

## 12.4、stop方法停止线程 → 已过时
suspend → 会发生死锁 → 已过时

如何停止线程？  
run方法运行结束，线程就结束了，这是目前结束的唯一方法。 

开启多线程运行，运行代码通常是循环结构。    
只要控制住循环，就可以让run方法结束，也就是线程结束。   

——————————————————————————————————————————      

如果有wait怎么办？  
强制让线程恢复运行，Thread提供interrupt方法，
可以清除线程的冻结状态。

```java
StopThread st = new StopThread();

Thread t1 = new Thread(st);
t1.interrupt();
```

——————————————————————————————————————————      

## 12.5、守护线程
```java
// 在启动线程时调用，启动守护线程
t1.setDaemon(true);
t1.start();
```
——————————————————————————————————————————      

## 12.6、join
join主要用于等待线程的终止。

join，比较少用。

```java
t1.start();
t1.join();  // 阻塞当前线程，等待t1结束运行，再向下执行
```
——————————————————————————————————————————      

## 12.7、ThreadGroup

线程组，用的比较少。

线程优先级，从1-10，默认是5，
- 1 → MIN_PRIORITY
- 5 → NORM_PRIORITY
- 10 → MAX_PRIORITY

```java
Thread.yield(); // 当前线程释放CPU的占用。
```

——————————————————————————————————————————      
