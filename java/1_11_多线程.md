# Vol.11

## 11.1、多线程

进程是一个正在执行中的程序，    
每个进程执行都有一个执行顺序。  

线程是CPU调度的基本单位。   

java 虚拟机启动时，会有一个进程java.exe，   
该进程中至少有一个线程，    
该线程的程序就在main方法中，也就是主线程，至少还会有一个垃圾回收的线程。

为什么要有线程？    
计算机操作系统的基础知识。

——————————————————————————————————————————      

## 11.2、创建线程 —— 继承Thread类

Thread，就是程序中的执行线程，

要创建一个新线程，有两种方法
- 声明为Thread的子类，重写其run方法；
- 声明Runnable类，将其实例传入Thread对象。

```java
class Demo extends Thread
{
    public void run(){
        // 重写run方法，这里就是线程要执行的操作
    }
}

Demo d = new Demo();

// 注意，是用start方法来启动线程，而不是run方法。
d.start();
```

### 1、方式一：
- 1、定义一个子类extends Thread
- 2、重写run方法，run方法内部的就是线程需要执行的代码。
- 3、调用线程start方法， 启动线程，start方法会新开一个线程，去执行run方法。

——————————————————————————————————————————      

多个线程会竞争CPU的执行权，     
某一时刻，仅会有一个线程执行，CPU会在多个线程之间快速切换。     
宏观并行，微观串行。    

——————————————————————————————————————————      
### 2、为什么要复写run方法？

Thread 用于描述线程，run方法里面存放要运行的代码，
直接调用d.run()就失去了多线程的特性，变成串行。

**一定要用d.start()才会并行**。

——————————————————————————————————————————      

### 3、线程状态 → 和计算机操作系统里面的一样

### 4、线程对象和名称

```java
Thread.getName();   // 线程有自己的默认名称
Thread.setName("aaa");  // 自己设置一个名称

Thread.currentThread();     // 返回当前执行的线程对象。
```

> 注意：方式一不能多次start()，会报线程状态异常。   

### 5、方式二、
实现Runnable接口，实现run方法，

```java
// 1、定义一个类，实现Runnable接口，重写run方法
class Ticket implements Runnable{
    public void run(){
        // 这里写要执行的代码
    }
}

// 2、创建一个Ticket实例
Ticket t = new Ticket();

// 3、new Thread，把刚刚创建的Ticket实例传进去。
Thread t1 = new Thread(t);
Thread t2 = new Thread(t);

// 4、启动线程。
t1.start();
t2.start();
```

- 实现方式 → 避免了单继承的局限性，定义线程的时候，建议使用这种方式
- 继承方式 
    - 继承Thread，线程代码在Thread子类run中；
    - 实现Runnable，线程代码放在接口子类的run中。

——————————————————————————————————————————      

## 11.3、多线程的安全问题

写多线程，一定要关注安全问题。

```java
class Ticket implements Runnable{
    private int tick = 100;
    public void run(){
        while(true){
            if(tick>0){
                try{
                    Thread.sleep(10);
                }catch(Exception e){}

                // 如果多个线程启动，tick的值会趋向于不确定
                // 这就是安全问题
                tick--; 
            }
        }
    }
}
```

问题：  
多条语句操作一个线程共享数据，    
一个线程执行到一半，另一个线程又参与进行，会导致错误。

解决：  
多条操作共享的数据，让一个线程执行完，执行过程中，其他线程不可执行。        

——————————————————————————————————————————      

java → 使用同步代码块解决。
```java
synchronized(对象){
    // 需要同步的代码
}
```
```java 
class Ticket implements Runnable{
    private int tick = 100;
    Object obj = new Object();
    public void run(){
        while(true){
            // synchronized 里面传入的是锁，
            // 线程只有拿到了锁才能够运行同步代码块里面的内容
            // 也可以叫做：锁、同步锁、监视器
            synchronized(obj){
                if(tick > 0){
                    try{
                        Thread.sleep(10);
                        
                    }catch(Exception e){}

                    tick --;
                }
            }
        }
    }
}
```
没有持有锁的线程，即使拿到了CPU的执行权，   
也无法进入到同步代码块执行，因为没有锁。

弊端：  
消耗资源，程序运行更费时。  
并且，每个线程执行时都会判断锁。    

同步的前提：
- 两个以上的线程
- 多个线程使用同一个锁

必须保证同步中只能有一个线程在运行。

——————————————————————————————————————————      

## 11.4、同步函数

```java
// 原本的写法
class Bank{
    private int sum;
    Object obj = new Object();
    public void add(int n ){
        synchronized(obj){
            sum = sum + n;
            try{
                Thread.sleep(10);
            }catch(Exception e){}
        }
    }
}

// 同步函数的写法
class Bank{
    private int sum;
    // 用synchronized修饰，使之成为同步函数。
    public synchronized void add(int n ){

    }
}
```
> 注意：    
> 同步函数的锁，就是this对象。  
>   
> 要明确哪些部分是要同步的，哪些部分是不用同步的。  
> 不需要同步就不要同步，因为同步会降低运行效率。    

——————————————————————————————————————————      

## 11.5、public static void show(){}

静态函数也可以用synchronized修饰，此时使用的锁，就是当前class类。   

——————————————————————————————————————————      

## 11.6、多线程下的单例设计模式

单例设计模式有两种，
- 懒汉式
- 饿汉式

如果多线程的情况下，可能会有问题。
懒汉式在多线程情况下，可能会创建多个不同的单例。

解决：  
双重判断，提高懒汉式的延迟加载效率。    

练习：双重判断多线程懒汉式。

——————————————————————————————————————————      

## 11.7、死锁

同步中嵌套了同步，会导致死锁。  

两个synchronized，他们用了两个不同的锁。

练习：写一个死锁出来。

——————————————————————————————————————————      
