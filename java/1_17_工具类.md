# Vol.17 Utilities

## 17.、 Collections

工具类
- Collection
- Collections ：专门用于对Collection进行操作

    - 可以对List集合进行排序、二分查找，注意，线程不安全

    - Tips：要使用多线程，需要用里面的同步方法，
        - 注意，Set不需要用这个排序，Set有TreeSet排序，


类似的还有Array和Arrays
- Array
- Arrays ：专门用于对Array进行操作

——————————————————————————————————————————      

```java
import java.util.*;

List<String> list = new ArrayList<String>()
list.add("1111");
list.add("aaa");
list.add("bbb");
list.add("eee");
list.add("zzz");
list.add("yyy");

// Collections提供了一个sort方法
Collections.sort(list);
// 第二参数还可以传入一个比较器，来自定义排序
Collections.sort(list,new StrLenComparator);

class StrLenComparator implements Comparator<String>
{
    public int compare(String s1,String s2){
        if(s1.length() > s2.length()){
            return 1;
        }
        if(s1.length() < s2.length()){
            return -1;
        }
        return s1.compareTo(s2);
    }
}
```
```java
// 返回list的最大值
String max = Collections.max(list);

// 获取某一个字符串在list中的索引，没有则返回-1
int index = Collections.binarySearch(list,"aaa");
```

——————————————————————————————————————————      
## 17.2、集合替换

```java
// 将集合中的元素全部替换为p
Collections.fill(list,"p");

// 将所有的aa替换成pp
Collections.replaceAll(list,"aa","pp");

Collections.reverse(list);


// 逆转比较器，排出来的顺序是反的，
// 传入到一个二叉树中，可以指定二叉树的排序规则
Collections.reverseOrder(new StrLenComparator());
// 在构造一个TreeSet的时候传入
TreeSet<String> ts = new TreeSet<String>(Collections.reverseOrder(new StrLenComparator()));

```

——————————————————————————————————————————      

## 17.3、Arrays

是一个用于操作数组的工具类
```java
import java.util.*;

Arrays.sort(arr);

// 将数组转成字符串
String a = Arrays.toString(arr);

// 将数组变成list集合，
// 然后就可以用集合的方法来操作数组了。
List li = Arrays.asList(arr)

```
> Tips：    
> 如果将数组转成了List集合，此时可以用集合的方法来操作数组，    
> 但是，不能增删，因为Array的长度本身是固定的，     
> 如果发生了增删，会抛异常。    

——————————————————————————————————————————      

这里有一个细节：
```java
int[] arr = {2,3,4};
// 此时li是一个 [[2,3,4]]，这并不是我们要的
List li = Arrays.asList(arr);

Integer[] nums = {2,3,4};
// 此时的li， 就是[2,3,4]
List<Integer> li = Arrays.asList(arr);
```
Arrays.asList，会将对象放进List中，     
而如果数组的内部是基本数据类型，会把基本数据类型外层的对象当成List元素

——————————————————————————————————————————      

## 17.4、集合变数组 toArray
```java
ArrayList<String> a1 = new ArrayList<String>();
a1.add("aaabababa");
a1.add("zfsdgdfsd");

String[] arr = a1.toArray( new String( [a1.size()] ) );
```

——————————————————————————————————————————      

## 17.5、对集合进行遍历 forEach
```java
ArrayList a1 = new ArrayList<String>();

// 高级for循环
for(String s:a1)
{
    System.out.println(s);
}

// 以前的迭代器
Iterator<String> it = a1.iterator();
while(it.hasNext()){
    System.out.println(it);
}
```
两个有啥不同？
- 高级for循环需要有被遍历的目标，
- 迭代器则是通过hasNext判断。
- 而以前的for循环则可以自定义角标。

本来，集合可以用迭代器遍历，现在可以用forEach   

> 注意，    
> for里面对集合的操作，对集合本身都不会有作用。         

——————————————————————————————————————————      

## 17.6、方法的可变参数

```java
// 以前的写法，如果形参很多，且类型都一样，则名称很长
public static void show(String str,int a, int b,int c){

}

// v1.5有了一种省略写法
public static void show(String str,int...arr){
    System.out.println(arr.length);
}
// 省略写法中，传入的多个同类型参数，会被放到数组arr中，而不是枚举。
show("aaaaa",123,534,23,4345,743,434,75);
```
> 注意：    
> 可变参数标识...要放到形参的末尾，而其他枚举的类型放到前面部分。   

——————————————————————————————————————————      

## 17.7、静态成员导入

```java
// 以前的导入
import java.util.*;

// 导入Arrays中的所有的静态成员
import static java.util.Arrays.*;
```

> 导入Arrays中的所有的静态成员之后，    
> 可以直接用Arrays内部的静态方法，  
>   
> 但是，如果方法重名，此时就要指定具体的所属类或对象。  

——————————————————————————————————————————      
