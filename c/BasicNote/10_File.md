# 10_文件

- 文本文件：基于字符编码，如ASCII、UNICODE
- 二进制文件

文件打开    
```c
FILE *fopen(filename, mode);

// 系统自己定义了一个结构体，叫做FILE
// mode表示打开文件的模式

/*
mode的取值
    r rb    以只读方式打开
    w wb    以写方式打开
    a ab    以追加方式打开，在末尾添加内容
    r+ rb+  以可读可写方式打开，不创建新文件
    w+ wb+  以可读可写方式打开，文件如果存在则清空
    a+ ab+  以添加的方式打开文件

Tips：b是指二进制模式，windows专用；
*/
```
```c
FILE *fp = fopen("xx.txt","r");
if(fp == NULL)
{
    printf("文件打开失败"); 
    return;
}
printf("打开失败");

fclose(fp); //关闭文件

/*
文件打开失败有几种情况
1、找不到文件，路径不对
2、没有读写权限
3、程序打开文件的数量超出上限（一般是限制65535个文件）；
*/

fputc('A',fp); // 覆盖写入
char ch = fgetc(fp); // 读取一个字符

while(ch == fgetc(fp) != EOF)

/*
文件结尾 EOF 默认值是-1;
用一次fgetc，就会从文件中读取一个字符，并且文件中的光标会向前走一步；
*/
```
---------------------------------------------

```c
char ch;
while((ch = fgetc(fp)) != EOF)
{
    printf("%c\n",ch);
}
// EOF的ASCII值为-1，而ASCII中字符的值全为正，所以可以用来作为结束标志；
```
---------------------------------------------

```c

char ch = 'a';
FILE *fp = fopen("./b.txt","a");
fputc(ch,fp);
ch = 'b';
fputc(ch, fp);  // 此时b.txt文件内就有了字符串ab

```
---------------------------------------------

```c
// 例、实现一个vi编辑器
scanf("%s",fileName);
getchar(); // scanf的结束时用\n，getchar则是用来接收\n，避免多次scanf导致问题；

// 更新缓冲区，比如说录入的时候终端了程序，原有的输入内容用fflush就会被缓存下来；
fflush(p); 

// 目标：使用命令 myvi ./a.txt 就可以对a.txt进行编辑
```
---------------------------------------------
```c
// 例、实现cat，即查看文本文件；
// cat ./a.txt  此时就会显示出文件的所有内容
```
```c
// 例、四则运算
sprint(buf, "%d%c%d=\n",a,b,c);
// 例如键入2*3=\n，就会放入buf中
```
```c
// 文件的加密解密
/*
简单的加密
    1、读取文件，将里面的字符的ASCII码全部加1，
    2、将读取后处理的内容写入到另外一个文件中；

解密
    1、读取文件，讲礼貌的字符的ASCII码全部减1，
    2、将处理后的内容写入到另一个文件中

Tips：系统md5就是一种常用的加密方式；
*/
```
----------------------------------------------
按字符读写文件 → 每次使用则读取一个字符
- 读 fgetc()
- 写 fputc()
- 是否到文件结尾 feof()

按行读写文件 → 也叫块读取，可以指定读取的长度
- 读 fgets()
- 写 fputs()
```c
char buf[1024];
fgets(buf, 5,fp); 
/*
fp是通过fopen获取到的fileStream
5是读取的数量，在实际读取时，传入5，会读4个字符，还剩1个字符为\0作为字符的结束；
读取的数量可以超过fp的大小
*/
```
----------------------------------------------
```c
// char 直接定义的buf存放到栈里面，空间有限
char buf[1024]; 

// 使用malloc申请的空间在堆空间内，空间很大
char *uf = malloc(sizeof(char *) * 1024);
```
```c
while(feof(fp) == 0){}
/*
feof()判断文件是否到了结尾
    =0  说明没有到结尾
    ≠0  说明已经到了结尾

Tips：EOF是判断字符的结尾，而feof()则是判断文件流是否到末尾
*/
```
```c
/*
字符串的格式化读出：从buf中，按照"%d%c%d=\n"的格式，提取各个变量值，赋值到abc当中
*/
sscanf(buf, "%d%c%d=\n",&a,&b,&c);


/*
文件的格式化写入：将a b c value按照"%d%c%d=%.2f\n"的格式组成字符串，存入到buf中
*/
fprintf(buf, "%d%c%d=%.2f\n",a,b,c,value);

// 上面这句等价于
memset(buf,0,20);
sprintf(buf,"%d%c%d=%.2f\n",a,b,c,value);
fputs(buf,fp2);

/*
文件的格式化读取
*/
fscanf(fp1, "%d+%d=%d\n",&a, &b, &c);
```












